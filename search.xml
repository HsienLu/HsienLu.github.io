<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>部落格介紹</title>
    <url>/2023/12/29/20231228-first/</url>
    <content><![CDATA[<h2 id="關於我"><a href="#關於我" class="headerlink" title="關於我"></a>關於我</h2><p>剛踏入前端職場的小菜雞，平常喜歡看看技術文章，順便做做筆記，有時候也會寫一些奇怪的東西，歡迎來到我的部落格。</p>
]]></content>
  </entry>
  <entry>
    <title>TypeScript-常用功能-Readonly</title>
    <url>/2024/01/31/TypeScript-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD-Readonly/</url>
    <content><![CDATA[<p>Readonly 其實從字面上很好理解，就是指能讀取的意思。<br>根據官方文件的說方就是不能被創造一個 Type 的型別物件，其設置的屬性不能被重新賦值。</p>
<blockquote>
<p>Constructs a type with all properties of Type set to readonly, meaning the properties of the constructed type cannot be reassigned.</p>
</blockquote>
<span id="more"></span>

<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ol>
<li>整個型別都不能被重新賦值</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">todo</span>: <span class="title class_">Readonly</span>&lt;<span class="title class_">Todo</span>&gt; = &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&quot;Delete inactive users&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo.<span class="property">title</span> = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以個別設置屬性為 readonly</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">bar</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">bas</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">foo</span>: <span class="title class_">Foo</span> = &#123;<span class="attr">bar</span>: <span class="number">123</span>, <span class="attr">bas</span>: <span class="number">456</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能被重新賦值</span></span><br><span class="line">foo.<span class="property">bar</span> = <span class="number">456</span>; <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h4 id="實際使用場景"><a href="#實際使用場景" class="headerlink" title="實際使用場景"></a>實際使用場景</h4><p>React 中的 props 就是一個很好的使用場景，因為 React 為單向資料流，子組件不能修改父組件傳遞過來的 props，所以可以使用 Readonly 來設置 props 的型別，預防突然犯傻直接修改了 props。</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyComponentProps</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props: MyComponentProps</span>) &#123;</span><br><span class="line">  <span class="comment">// 使用 props.name，但不能修改它</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 的 LeetCode-TypeHero</title>
    <url>/2024/01/26/TypeScript-%E7%9A%84-LeetCode-TypeHero/</url>
    <content><![CDATA[<p>近幾年很火的 TypeScript 加強了 JavaScript 的型別部分，但 TypeScipt 的型別系統其實相當的複雜，於是有人開源了類似 LeetCode 的網站，讓我們可以練習 TypeScript 的型別系統，這個網站就是 TypeHero，今天就來介紹一下這個網站吧!</p>
<span id="more"></span>

<h5 id="TypeHero-https-typehero-dev"><a href="#TypeHero-https-typehero-dev" class="headerlink" title="TypeHero:https://typehero.dev/"></a>TypeHero:<span class="exturl" data-url="aHR0cHM6Ly90eXBlaGVyby5kZXYv">https://typehero.dev/<i class="fa fa-external-link-alt"></i></span></h5><h3 id="操作介面"><a href="#操作介面" class="headerlink" title="操作介面"></a>操作介面</h3><p>操作介面相當簡單易懂的，左邊是題目，右邊是編輯器，下方是測試結果，上方是編輯器的設定，可以選擇編輯器的主題，以及是否顯示行號。</p>
<h4 id="說明區"><a href="#說明區" class="headerlink" title="說明區"></a>說明區</h4><p>1.Description(說明):附帶蠻詳細有關 TypeScript 的解說<br>2.Solutionru(解答):裡面會有需多人提供參考答案在上頭<br>3.Submissions(提交):可以看到自己每一次的提交紀錄</p>
<h4 id="解答區"><a href="#解答區" class="headerlink" title="解答區"></a>解答區</h4><p>提供一個簡單的編輯器，進行解答。<br>題目會像是下面這種形式，然後要補充缺少的型別或是成是碼。</p>
<h6 id="未完成題目"><a href="#未完成題目" class="headerlink" title="未完成題目"></a>未完成題目</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">playSong</span> = (<span class="params">artistName, year</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;artistName&#125;</span> was released in the year <span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> artistName = <span class="string">&quot;Frank Zappa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">52</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Musician</span> &#123;</span><br><span class="line">  <span class="attr">artistName</span>: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// add the rest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">musicianInfo</span> = (<span class="params">&#123;artistName, age, deceased&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;artistName&#125;</span>, age <span class="subst">$&#123;age&#125;</span><span class="subst">$&#123;deceased ? <span class="string">&quot; (deceased)&quot;</span> : <span class="string">&quot;&quot;</span>&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">musicianInfo</span>(&#123;</span><br><span class="line">  artistName,</span><br><span class="line">  age,</span><br><span class="line">  <span class="attr">deceased</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h6 id="完成後的樣子"><a href="#完成後的樣子" class="headerlink" title="完成後的樣子"></a>完成後的樣子</h6><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">playSong</span> = (<span class="params">artistName: <span class="built_in">string</span>, year: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;artistName&#125;</span> was released in the year <span class="subst">$&#123;year&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">artistName</span>: <span class="built_in">string</span> = <span class="string">&quot;Frank Zappa&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">age</span>: <span class="built_in">number</span> = <span class="number">52</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Musician</span> &#123;</span><br><span class="line">  <span class="attr">artistName</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">deceased</span>: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="comment">// add the rest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">musicianInfo</span> = (<span class="params">&#123;artistName, age, deceased&#125;: Musician</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;artistName&#125;</span>, age <span class="subst">$&#123;age&#125;</span><span class="subst">$&#123;deceased ? <span class="string">&quot; (deceased)&quot;</span> : <span class="string">&quot;&quot;</span>&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">musicianInfo</span>(&#123;</span><br><span class="line">  artistName,</span><br><span class="line">  age,</span><br><span class="line">  <span class="attr">deceased</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="測試區"><a href="#測試區" class="headerlink" title="測試區"></a>測試區</h4><p>按下 submit 後，會進行測試，如果有錯誤會顯示在下方，如果沒有錯誤，會顯示通過。</p>
<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1706235228/1_spnmgy.png"></p>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>其實還蠻好玩的，可以有小範圍的練習機會，而且這種關卡的設計型式，通關後會有一種莫名的成就感，蠻適合像我這種初學的人~</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>TypeHero</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-遞迴</title>
    <url>/2024/01/25/Java-%E9%81%9E%E8%BF%B4/</url>
    <content><![CDATA[<p>遞迴是一種函式<code>呼叫自己的技巧</code>，遞迴的函式必須要有一個<code>終止條件</code>，否則會無限迴圈下去，直到記憶體爆掉為止。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Recursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> sum(<span class="number">10</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k + sum(k - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-訪問權限</title>
    <url>/2024/01/25/Java-%E8%A8%AA%E5%95%8F%E6%AC%8A%E9%99%90/</url>
    <content><![CDATA[<p>所謂的訪問權限，其實就是訪問屬性、方法的權利和限制</p>
<span id="more"></span>

<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><ol>
<li>public: 公共的,任意使用,訪問權限修飾符</li>
<li>Java 中的<code>public class</code>只能有一個,且必須與檔名相同</li>
<li>main 方法必須是 public static void,不加不能使用，因為 main 方法是由 JVM 調用的，JVM 應該可以任意調用，不該受到限制。</li>
<li>static: 靜態的,靜態方法,靜態變數,靜態代碼塊,main 方法不加 staitic,一樣不能使用</li>
</ol>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><ol>
<li>private: 私有的,訪問權限修飾符</li>
<li>private 修飾的變數,只能在所屬類中使用</li>
</ol>
<h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><ol>
<li>(default): 默認的,當沒有設定訪問權限修飾符時,JVM 會默認提供一個訪問權限，就是 package(路徑)訪問權限，子 package 不能使用</li>
<li>default 修飾的變數,只能在同一包中使用</li>
</ol>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><ol>
<li>protected: 受保護的,訪問權限修飾符</li>
<li>protected 修飾的變數,只能在同一包中使用,同 package 或是不同 package 子類都可以使用</li>
</ol>
<h3 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h3><p>訪問權限由小到大排列<br>1.private: 只能在本類中使用<br>2.(default): 只能在同一包中使用,不同的包路徑就不能使用<br>3.protected: 只能在同一包中使用,同包或是不同包子類都可以使用<br>4.public: 任意使用,JVM 預設給的構造方法</p>
<h2 id="類的訪問權限"><a href="#類的訪問權限" class="headerlink" title="類的訪問權限"></a>類的訪問權限</h2><h4 id="外部類"><a href="#外部類" class="headerlink" title="外部類"></a>外部類</h4><p>就是直接在程式碼中定義的類 1.外部類只能是 public 或是 (default) 修飾</p>
<h4 id="內部類"><a href="#內部類" class="headerlink" title="內部類"></a>內部類</h4><p>就是在類中定義的類 1.內部類可以是 public、protected、(default)、private 修飾 2.內部類就當成外部類的屬性或是方法來使用</p>
<h5 id="內部類如何創建"><a href="#內部類如何創建" class="headerlink" title="內部類如何創建"></a>內部類如何創建</h5><p>因為內部類是外部類的屬性或是方法，所以必須先創建外部類，才能創建內部類</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//內部類要先創建外部類</span></span><br><span class="line">        <span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        inner.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h2><p>Java 中提供一種語法，可以讓初始化的變數或是方法或是類不被改變，這種語法就是 final</p>
<ol>
<li>final 修飾的變數,只能被賦值一次,不能再次賦值</li>
<li>final 不能被 JVM 默認賦值,必須手動賦值</li>
<li>final 修飾的方法不能被覆寫</li>
<li>final 修飾的類不能被繼承，也就是不能有子類</li>
<li>final 不能修飾建構方法</li>
<li>final 可以修改方法的參數，一旦修飾就不能被修改</li>
</ol>
<p>常用的方法搭配構造方法使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="單例模式"><a href="#單例模式" class="headerlink" title="單例模式"></a>單例模式</h2><h4 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境:"></a>使用情境:</h4><ol>
<li>當需要創建一個類的實例，但是又不希望每次創建新的實例時都創建一個新的時候</li>
</ol>
<h4 id="實作概念"><a href="#實作概念" class="headerlink" title="實作概念:"></a>實作概念:</h4><ol>
<li>單例模式是一種常用的設計模式</li>
<li>在單例模式中，類的構造方法是私有的</li>
<li>在單例模式中，類必須自行創建一個實例</li>
<li>在單例模式中，類必須自行向整個系統提供這個實例</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SingleMode</span> <span class="variable">singleMode1</span> <span class="operator">=</span> SingleMode.getInstance();</span><br><span class="line">        <span class="type">SingleMode</span> <span class="variable">singleMode2</span> <span class="operator">=</span> SingleMode.getInstance();</span><br><span class="line">        System.out.println(singleMode1 == singleMode2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMode</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingleMode</span> <span class="variable">singleMode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingleMode</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SingleMode <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleMode == <span class="literal">null</span>)&#123;</span><br><span class="line">            singleMode = <span class="keyword">new</span> <span class="title class_">SingleMode</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  singleMode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-靜態方法</title>
    <url>/2024/01/25/Java-%E9%9D%9C%E6%85%8B%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<ul>
<li>靜態方法是一種特殊的方法，它可以在不創建類的情況下使用。</li>
<li>關鍵字 static 表示靜態方法，它屬於類，而不是屬於類的實例。</li>
<li>靜態方法可以直接使用類名.方法名調用</li>
<li>靜態方法不能訪問成員屬性和成員方法<span id="more"></span></li>
</ul>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TestStatic</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TestStatic</span>();</span><br><span class="line">        test.test1();</span><br><span class="line">        TestStatic.test2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStatic</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;non-static Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Static Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="靜態代碼塊"><a href="#靜態代碼塊" class="headerlink" title="靜態代碼塊"></a>靜態代碼塊</h3><p>類的程式載入完成後會自動執行的程式碼，只會執行一次。可以完成靜態屬性的初始化。</p>
<h4 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TestStatic t= <span class="keyword">new</span> <span class="title class_">TestStatic</span>();</span><br><span class="line">    TestStatic.test();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestStatic</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;static block&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>創建實例時也會執行代碼塊，但不是靜態代碼塊，而是代碼塊。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-特殊類別(介面、抽象、枚舉、匿名類)</title>
    <url>/2024/01/25/Java-%E7%89%B9%E6%AE%8A%E9%A1%9E%E5%88%A5-%E4%BB%8B%E9%9D%A2%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E6%9E%9A%E8%88%89%E3%80%81%E5%8C%BF%E5%90%8D%E9%A1%9E/</url>
    <content><![CDATA[<p>Java 有許多不同的特殊類別，例如：介面、抽象類別、枚舉類別、匿名類別，這些類別都有各自的特性，也有各自的使用場景，這篇文章會介紹這些特殊類別的特性與使用場景。</p>
<span id="more"></span>

<h2 id="介面-Interface"><a href="#介面-Interface" class="headerlink" title="介面(Interface)"></a>介面(Interface)</h2><p>可以簡單的理解為一個規則</p>
<h3 id="介面的特性"><a href="#介面的特性" class="headerlink" title="介面的特性"></a>介面的特性</h3><ol>
<li>介面都是抽象的</li>
<li>規則的屬性為固定值,且不能修改</li>
<li>屬性和行為的訪問權限必須為公共的</li>
<li>屬性是靜態的</li>
<li>行為是抽象的</li>
<li>介面和類是不一樣的東西</li>
<li>介面可以繼承多個介面</li>
<li>類的物件需要遵循介面，在 Java 中這個動作叫做實現(implements)，類需要實現介面，而且可以實現多個介面</li>
</ol>
<h3 id="介面的語法"><a href="#介面的語法" class="headerlink" title="介面的語法"></a>介面的語法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Computer c=<span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">    Light l1=<span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">    Light l2=<span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">    c.usb1=l1;</span><br><span class="line">    c.usb2=l2;</span><br><span class="line">    c.powerSupply();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USBInterface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USBSupply</span> <span class="keyword">extends</span> <span class="title class_">USBInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerSupply</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USBReceive</span> <span class="keyword">extends</span> <span class="title class_">USBInterface</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerReceive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span> <span class="keyword">implements</span> <span class="title class_">USBSupply</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> USBReceive usb1;</span><br><span class="line">    <span class="keyword">public</span> USBReceive usb2;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerSupply</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Computer is supplying power&quot;</span>);</span><br><span class="line">    usb1.powerReceive();</span><br><span class="line">    usb2.powerReceive();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span> <span class="keyword">implements</span> <span class="title class_">USBReceive</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">powerReceive</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Light is receiving power&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象-Abstract"><a href="#抽象-Abstract" class="headerlink" title="抽象(Abstract)"></a>抽象(Abstract)</h2><p>只有宣告沒有實作的方法</p>
<h3 id="抽象方法-Abstract-Method"><a href="#抽象方法-Abstract-Method" class="headerlink" title="抽象方法(Abstract Method)"></a>抽象方法(Abstract Method)</h3><h4 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h4><blockquote>
<p>abstract 返回值類型 方法名稱(參數列表);</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象類別-Abstract-Class"><a href="#抽象類別-Abstract-Class" class="headerlink" title="抽象類別(Abstract Class)"></a>抽象類別(Abstract Class)</h3><p>1.因為類不完整，所以不能被實體化，只能被繼承 2.如果一個類有抽象方法，那麼該類必須定義為抽象類 3.抽象類可以有抽象方法，也可以有非抽象方法 4.抽象類無法直接實體化，必須由子類繼承實現間接的實體化 5.如果抽象類有抽象方法，那麼子類必須重寫抽象方法</p>
<h4 id="語法-1"><a href="#語法-1" class="headerlink" title="語法"></a>語法</h4><blockquote>
<p>abstract class 類別名稱{…}</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog eat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚舉-Enum"><a href="#枚舉-Enum" class="headerlink" title="枚舉(Enum)"></a>枚舉(Enum)</h2><p>1.枚舉是一個特殊的類別，其中包含一組特定對象，這些對象不會發生改變 2.關鍵字 enum 用來宣告一個枚舉 3.枚舉會將對象放置在最前面,後面用分號隔開 4.枚舉不能創建對象，它是在內部創建的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaEnum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(City.TAIPEI.name);</span><br><span class="line">    System.out.println(City.TAICHUNG.name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">City</span>&#123;</span><br><span class="line">    TAIPEI(<span class="string">&quot;台北&quot;</span>),TAICHUNG(<span class="string">&quot;台中&quot;</span>),TAINAN(<span class="string">&quot;台南&quot;</span>);</span><br><span class="line">    City(String name)&#123;</span><br><span class="line">        <span class="built_in">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="匿名類-Anonymous"><a href="#匿名類-Anonymous" class="headerlink" title="匿名類(Anonymous)"></a>匿名類(Anonymous)</h2><p>在某些場合，類的名子不重要，指向使用類中的方法或功能<br>如下範例，直接在方法中建立一個類，並且實作方法，並且在方法中使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaAnonymousClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Me</span> <span class="variable">me</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Me</span>();</span><br><span class="line">    me.sayHello(<span class="keyword">new</span> <span class="title class_">Person</span>()&#123;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">name</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;John&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Me</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span> + person.name());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 物件導向的特性</title>
    <url>/2024/01/24/Java-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%9A%84%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>Java 身為標準的物件導向程式設計語言，物件導向程式設計的特性有繼承、多型、多載、重寫，這些特性都是為了讓程式碼更加的模組化，讓程式碼更加的容易維護與擴充。</p>
<span id="more"></span>

<h3 id="物件導向程式設計的特性"><a href="#物件導向程式設計的特性" class="headerlink" title="物件導向程式設計的特性"></a>物件導向程式設計的特性</h3><h4 id="繼承-Extends"><a href="#繼承-Extends" class="headerlink" title="繼承(Extends)"></a>繼承(Extends)</h4><p>1.父類別是在子類別建構出來前就就建構出來的，子類別會繼承父類別的屬性與方法，完成父類別的建構後。 2.以物件的概念，每一個子類對應到的父類都是各自獨立的，而子類繼承父類的屬性與方法，就是子類繼承父類的物件。<br>3.super()可以呼叫父類的建構方法，super.可以呼叫父類的屬性與方法。this()可以呼叫自己的建構方法，this.可以呼叫自己的屬性與方法。 4.如果父類提供建構方法，那麼 JVM 不會自動提供預設建構方法，所以子類必須要有對應的建構方法，否則會出現錯誤。</p>
<p>以 JAVA 為例，繼承的語法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">class 父類別 &#123;</span><br><span class="line">    <span class="comment">// 父類別的屬性與方法</span></span><br><span class="line">&#125;</span><br><span class="line">class 子類別 extends 父類別 &#123;</span><br><span class="line">    <span class="comment">// 子類別的屬性與方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="多型-Polymorphism"><a href="#多型-Polymorphism" class="headerlink" title="多型(Polymorphism)"></a>多型(Polymorphism)</h4><p>所謂的多型，就是同一個物件在不同場景下，會有不同的表現形式。 1.多型其實會在對物件的使用場景下進行限制，例如：父類別的物件只能使用父類別的屬性與方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Person p1=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p1.sayPerson();</span><br><span class="line">    Person p2=<span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    p2.sayPerson();</span><br><span class="line">    p2.sayBoy();<span class="comment">//這裡會出現錯誤，只能使用Person的屬性與方法，不能使用Boy的屬性與方法。</span></span><br><span class="line">    <span class="comment">//改成如下</span></span><br><span class="line">    Boy b2= <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">    b2.sayBoy();</span><br><span class="line"></span><br><span class="line">    Person p3=<span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">    p3.sayPerson();</span><br><span class="line">    p3.sayGirl();<span class="comment">//這裡會出現錯誤，只能使用Person的屬性與方法，不能使用Girl的屬性與方法。</span></span><br><span class="line">    <span class="comment">////改成如下</span></span><br><span class="line">    Girl g3=<span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">    g3.sayGirl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">       <span class="keyword">void</span> <span class="title function_">sayPerson</span><span class="params">()</span>&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;I am a person&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">sayBoy</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I am a boy&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="多載-Overload"><a href="#多載-Overload" class="headerlink" title="多載(Overload)"></a>多載(Overload)</h4><p>1.一個類別中，不能重複宣告相同名稱的方法，這裡的相同是指方法名稱與參數列表都相同，與返回值無關，但是可以宣告相同名稱的方法，只要參數列表不同(個數、順序、類型)即可，這就是所謂的方法多載。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LoginApp</span> <span class="variable">loginApp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginApp</span>();</span><br><span class="line">        loginApp.Login(<span class="string">&quot;123456789&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        loginApp.Login(<span class="number">123456789</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        loginApp.Login(<span class="string">&quot;11@11&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LoginApp</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Login</span><span class="params">(String account,String password)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;帳號密碼登入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Login</span><span class="params">(Number phone,String password)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;手機號碼密碼登入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">Login</span><span class="params">(String email)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;email登入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.構造方法也有多載</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">LoginApp</span> <span class="variable">loginApp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginApp</span>();</span><br><span class="line">    loginApp.LoginApp();</span><br><span class="line">    loginApp.LoginApp(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LoginApp</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">LoginApp</span><span class="params">()</span>&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;原生&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">LoginApp</span><span class="params">(String name)</span>&#123;</span><br><span class="line">         System.out.println( name+<span class="string">&quot;重载&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重寫-Override"><a href="#重寫-Override" class="headerlink" title="重寫(Override)"></a>重寫(Override)</h4><p>子類別可以重寫父類別的方法，但是要注意的是，子類別重寫父類別的方法時，方法名稱、參數列表、返回值都要相同。 1.一個類能使用什麼方法取決於引用的變數類型 2.一個類能使用什麼屬性取決於引用的變數類型 3.一個類的方法如何實現取決於實際的物件類型 4.一個類的屬性具體的使用不需要考慮實際的物件，屬性在哪裡宣告在哪裡使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> basic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">helloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Child</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">        c.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Parent&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m a parent&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Child&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I&#x27;m a child&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript-介面(interface) vs 型別別名(Aliases)</title>
    <url>/2024/01/19/TypeScript-%E4%BB%8B%E9%9D%A2-interface-vs-%E5%9E%8B%E5%88%A5%E5%88%A5%E5%90%8D-Aliases/</url>
    <content><![CDATA[<p>開頭先引用一下官方文件的說明</p>
<blockquote>
<p>Type aliases and interfaces are very similar, and in many cases you can choose between them freely. Almost all features of an interface are available in type, the key distinction is that a type cannot be re-opened to add new properties vs an interface which is always extendable.</p>
</blockquote>
<span id="more"></span>

<p>這段文字簡單來說就是兩著幾乎相同，但是有一個很大的差別就是介面可以被擴充，但是型別別名不行。那其實只要選擇擴充性高的話就好了呀，為什麼還要有型別別名呢？<br>以下就來比較差異和共同點吧!</p>
<h3 id="宣告方式"><a href="#宣告方式" class="headerlink" title="宣告方式"></a>宣告方式</h3><p>一個是使用&#x3D;，另個一個是物件的方式</p>
<h5 id="介面"><a href="#介面" class="headerlink" title="介面"></a>介面</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="型別別名"><a href="#型別別名" class="headerlink" title="型別別名"></a>型別別名</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="宣告型別"><a href="#宣告型別" class="headerlink" title="宣告型別"></a>宣告型別</h3><h5 id="介面-1"><a href="#介面-1" class="headerlink" title="介面"></a>介面</h5><p>不能宣告基本型別，只能宣告物件型別，而且可以重複宣告，並且會合併</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">account</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">money</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Amy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">acount</span>: <span class="string">&quot;AAA&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">2000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Amy</span>);</span><br></pre></td></tr></table></figure>

<h5 id="型別別名-1"><a href="#型別別名-1" class="headerlink" title="型別別名"></a>型別別名</h5><p>可以宣告基本型別和物件型別，但是不能重複宣告，會報錯</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">account</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">money</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Amy</span>: <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">acount</span>: <span class="string">&quot;AAA&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">2000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Amy</span>);</span><br></pre></td></tr></table></figure>

<h3 id="擴充性"><a href="#擴充性" class="headerlink" title="擴充性"></a>擴充性</h3><p>介面可以被擴充，型別別名也可以但是是藉由交集的方式，所以會有一些限制，例如不能使用 extends，但是可以使用&amp;</p>
<h5 id="介面-2"><a href="#介面-2" class="headerlink" title="介面"></a>介面</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> account <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">account</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">money</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Amy</span>: account = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">acount</span>: <span class="string">&quot;AAA&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">2000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Amy</span>);</span><br></pre></td></tr></table></figure>

<h5 id="型別別名-2"><a href="#型別別名-2" class="headerlink" title="型別別名"></a>型別別名</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> account = &#123;</span><br><span class="line">  <span class="attr">account</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">money</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125; &amp; <span class="title class_">Person</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Amy</span>: account = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">acount</span>: <span class="string">&quot;AAA&quot;</span>,</span><br><span class="line">  <span class="attr">money</span>: <span class="number">2000</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Amy</span>);</span><br></pre></td></tr></table></figure>

<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>初步整理一下，介面和型別別名的差異，表格如下:</p>
<table>
<thead>
<tr>
<th></th>
<th>介面</th>
<th>型別別名</th>
</tr>
</thead>
<tbody><tr>
<td>宣告型別</td>
<td>物件型別</td>
<td>物件型別和基本型別</td>
</tr>
<tr>
<td>重複宣告</td>
<td>可以，會合併</td>
<td>不能</td>
</tr>
<tr>
<td>擴充</td>
<td>可以，extend</td>
<td>藉由交集的方式</td>
</tr>
</tbody></table>
<p>回到一開始的問題，那為什麼還要有型別別名呢？</p>
<p>以初學的階段而言需要使用到的時機就在於<strong>基本型別</strong>吧!因為 ts 本身的限制，有些時候會需要使用到基本型別，但是又想要擴充，這時候就可以使用型別別名，但是如果是物件型別的話，那就可以使用介面，因為介面可以被擴充，所以就沒有必要使用型別別名了。</p>
]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-事務(Transaction)</title>
    <url>/2024/01/18/MySQL-%E4%BA%8B%E5%8B%99-Transaction/</url>
    <content><![CDATA[<p>簡介: 事務(Transaction)是一個邏輯上的工作單位，它可以包含一個或多個 SQL 語句</p>
<span id="more"></span>

<p>簡介: 事務(Transaction)是一個邏輯上的工作單位，它可以包含一個或多個 SQL 語句。事務可以讓一組 SQL 語句作為一個單元來執行，這些語句要麼全部執行，要麼全部不執行。事務是一個不可分割的工作執行單元，事務中包含的 SQL 語句要麼全部執行，要麼全部不執行，事務在執行過程中發生錯誤，會被回滾(Rollback)到事務開始前的狀態，事務在執行過程中沒有發生錯誤，會被提交(Commit)。</p>
<h2 id="事務操作"><a href="#事務操作" class="headerlink" title="事務操作"></a>事務操作</h2><h3 id="開啟事務"><a href="#開啟事務" class="headerlink" title="開啟事務"></a>開啟事務</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"><span class="keyword">BEGIN</span>;</span><br></pre></td></tr></table></figure>

<h3 id="提交事務"><a href="#提交事務" class="headerlink" title="提交事務"></a>提交事務</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<h3 id="回滾事務"><a href="#回滾事務" class="headerlink" title="回滾事務"></a>回滾事務</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure>

<h2 id="事務特性-ACID"><a href="#事務特性-ACID" class="headerlink" title="事務特性(ACID)"></a>事務特性(ACID)</h2><h3 id="原子性-Atomicity"><a href="#原子性-Atomicity" class="headerlink" title="原子性(Atomicity)"></a>原子性(Atomicity)</h3><p>事務是一個不可分割的工作執行單元，事務中包含的 SQL 語句要麼全部執行，要麼全部不執行，事務在執行過程中發生錯誤，會被回滾(Rollback)到事務開始前的狀態，事務在執行過程中沒有發生錯誤，會被提交(Commit)。</p>
<h3 id="一致性-Consistency"><a href="#一致性-Consistency" class="headerlink" title="一致性(Consistency)"></a>一致性(Consistency)</h3><p>事務在執行過程中，數據庫會從一個一致性狀態轉換到另一個一致性狀態，事務開始前和結束後，數據庫的完整性約束沒有被破壞。</p>
<h3 id="隔離性-Isolation"><a href="#隔離性-Isolation" class="headerlink" title="隔離性(Isolation)"></a>隔離性(Isolation)</h3><p>事務的隔離性是指多個事務並發執行時，一個事務的執行不會被其他事務干擾，多個事務並發執行時，一個事務內部的操作及使用的數據對其他事務是隱藏的，其他事務的操作及使用的數據對該事務也是隱藏的。</p>
<h3 id="持久性-Durability"><a href="#持久性-Durability" class="headerlink" title="持久性(Durability)"></a>持久性(Durability)</h3><p>事務完成後(提交或是回滾)，事務對數據的修改被永久保存到數據庫中，即使發生故障也不會丟失。</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">money <span class="type">int</span></span><br><span class="line"></span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span></span><br><span class="line">(&quot;AAA&quot;,<span class="number">2000</span>),</span><br><span class="line">(&quot;BBB&quot;,<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES <span class="operator">=</span> <span class="number">0</span>; <span class="comment">-- 關閉安全模式</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money<span class="operator">=</span>money<span class="number">-500</span> <span class="keyword">where</span> name<span class="operator">=</span>&quot;AAA&quot;;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money<span class="operator">=</span>money<span class="operator">+</span><span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span>&quot;BBB&quot;;</span><br><span class="line"><span class="keyword">SET</span> SQL_SAFE_UPDATES <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 開啟安全模式</span></span><br><span class="line"><span class="comment">-- commit; 預設式自動提交在mysql中</span></span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-約束條件</title>
    <url>/2024/01/18/MySQL-%E7%B4%84%E6%9D%9F%E6%A2%9D%E4%BB%B6/</url>
    <content><![CDATA[<p>MySQL 約束條件</p>
<span id="more"></span>

<h2 id="約束概念和分類"><a href="#約束概念和分類" class="headerlink" title="約束概念和分類"></a>約束概念和分類</h2><p>概念:約束條件是一種限制條件，用於限制變數的取值範圍，使得變數在取值時必須滿足某種條件。<br>約束分類表格</p>
<table>
<thead>
<tr>
<th align="center">約束分類</th>
<th align="center">約束名稱</th>
<th align="center">約束說明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NOT NULL</td>
<td align="center">非空約束</td>
<td align="center">限制變數不能為空值</td>
</tr>
<tr>
<td align="center">UNIQUE</td>
<td align="center">唯一約束</td>
<td align="center">限制變數不能重複</td>
</tr>
<tr>
<td align="center">PRIMARY KEY</td>
<td align="center">主鍵約束</td>
<td align="center">限制變數不能為空值且不能重複</td>
</tr>
<tr>
<td align="center">CHECK</td>
<td align="center">檢查約束</td>
<td align="center">限制變數必須滿足某種條件</td>
</tr>
<tr>
<td align="center">DEFAULT</td>
<td align="center">默認約束</td>
<td align="center">限制變數沒有給定值時，默認為某個值</td>
</tr>
<tr>
<td align="center">FOREIGN KEY</td>
<td align="center">外鍵約束</td>
<td align="center">限制變數的值必須在另一個表中存在</td>
</tr>
</tbody></table>
<h3 id="外鍵約束"><a href="#外鍵約束" class="headerlink" title="外鍵約束"></a>外鍵約束</h3><p>概念:外鍵約束是一種約束條件，用於限制變數的值必須在另一個表中存在。<br>外鍵約束的語法格式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> 外鍵名稱 <span class="keyword">FOREIGN</span> KEY (外鍵欄位名稱) <span class="keyword">REFERENCES</span> 另一個表名稱(另一個表的欄位名稱)</span><br></pre></td></tr></table></figure>

<p>外鍵約束的語法範例</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span> ,</span><br><span class="line"><span class="keyword">constraint</span> fk_emp_dept <span class="keyword">foreign</span> key(dep_id)</span><br><span class="line"><span class="keyword">references</span> dept(id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept (dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(&quot;RD&quot;,&quot;台北&quot;),</span><br><span class="line">(&quot;ME&quot;,&quot;台中&quot;);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (NAMe,age,dep_id) <span class="keyword">values</span></span><br><span class="line">(&quot;AAA&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;BBB&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;CCC&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;DDD&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;EEE&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;FFF&quot;,<span class="number">20</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>主表要先建立，外鍵表要後建立，否則會報錯</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-關聯資料表查詢</title>
    <url>/2024/01/18/MySQL-%E9%97%9C%E8%81%AF%E8%B3%87%E6%96%99%E8%A1%A8%E6%9F%A5%E8%A9%A2/</url>
    <content><![CDATA[<p>inner join、outer join、子查詢</p>
<span id="more"></span>

<h2 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h2><p>解釋: 用來查詢兩個表格中有關聯的資料，分成兩種寫法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1, table2 <span class="keyword">WHERE</span> table1.id <span class="operator">=</span> table2.id;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.id <span class="operator">=</span> table2.id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相當於取交集的意思</p>
</blockquote>
<h4 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立資料</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span> ,</span><br><span class="line"><span class="keyword">constraint</span> fk_emp_dept <span class="keyword">foreign</span> key(dep_id)</span><br><span class="line"><span class="keyword">references</span> dept(id)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept (dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(&quot;RD&quot;,&quot;台北&quot;),</span><br><span class="line">(&quot;ME&quot;,&quot;台中&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (NAMe,age,dep_id) <span class="keyword">values</span></span><br><span class="line">(&quot;AAA&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;BBB&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;CCC&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;DDD&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;EEE&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;FFF&quot;,<span class="number">20</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">-- 連接語法開始</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp , dept <span class="keyword">where</span> emp.dep_id <span class="operator">=</span> dept.id;</span><br><span class="line"><span class="comment">-- 另外一種寫法</span></span><br><span class="line"><span class="comment">-- SELECT * FROM emp JOIN dept ON dept.id = emp.dep_id;</span></span><br></pre></td></tr></table></figure>

<h2 id="outer-join"><a href="#outer-join" class="headerlink" title="outer join"></a>outer join</h2><p>解釋: 用來查詢兩個表格中有關聯的資料,並且會把沒有關聯的資料也查詢出來，又分成左外連結、右外連結、全外連結</p>
<h3 id="left-join"><a href="#left-join" class="headerlink" title="left join"></a>left join</h3><p>解釋: 用來查詢兩個表格中有關聯的資料,並且會把沒有關聯的資料也查詢出來，但是以左邊的表格為主</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.id <span class="operator">=</span> table2.id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取左邊表格的資料，並且把右邊表格的資料也查詢出來，如右邊沒有資料則顯示 null</p>
</blockquote>
<h4 id="範例-1"><a href="#範例-1" class="headerlink" title="範例"></a>範例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept (dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(&quot;RD&quot;,&quot;台北&quot;),</span><br><span class="line">(&quot;ME&quot;,&quot;台中&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (NAMe,age,dep_id) <span class="keyword">values</span></span><br><span class="line">(&quot;AAA&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;BBB&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;CCC&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;DDD&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;EEE&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;FFF&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;GGG&quot;,<span class="number">23</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id<span class="operator">=</span>dept.id;</span><br></pre></td></tr></table></figure>

<h3 id="right-join"><a href="#right-join" class="headerlink" title="right join"></a>right join</h3><p>解釋: 用來查詢兩個表格中有關聯的資料,並且會把沒有關聯的資料也查詢出來，但是以右邊的表格為主</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> table2 <span class="keyword">ON</span> table1.id <span class="operator">=</span> table2.id;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>取右邊表格的資料，並且把左邊表格的資料也查詢出來，如左邊沒有資料則顯示 null</p>
</blockquote>
<h4 id="範例-2"><a href="#範例-2" class="headerlink" title="範例"></a>範例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dep_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">addr <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span>,</span><br><span class="line">dep_id <span class="type">int</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> dept (dep_name,addr) <span class="keyword">values</span></span><br><span class="line">(&quot;RD&quot;,&quot;台北&quot;),</span><br><span class="line">(&quot;ME&quot;,&quot;台中&quot;),</span><br><span class="line">(&quot;QA&quot;,&quot;高雄&quot;),</span><br><span class="line">(&quot;EE&quot;,&quot;台南&quot;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp (NAMe,age,dep_id) <span class="keyword">values</span></span><br><span class="line">(&quot;AAA&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;BBB&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;CCC&quot;,<span class="number">20</span>,<span class="number">1</span>),</span><br><span class="line">(&quot;DDD&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;EEE&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;FFF&quot;,<span class="number">20</span>,<span class="number">2</span>),</span><br><span class="line">(&quot;GGG&quot;,<span class="number">23</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">right</span> <span class="keyword">join</span> dept <span class="keyword">on</span> emp.dep_id<span class="operator">=</span>dept.id;</span><br></pre></td></tr></table></figure>

<h3 id="子查詢"><a href="#子查詢" class="headerlink" title="子查詢"></a>子查詢</h3><p>解釋:重點是利用( )去包住查詢結果，並進一步的在外面加上查詢語法<br>基本語法</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 <span class="keyword">WHERE</span> table1.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> table2.id <span class="keyword">FROM</span> table2);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-SQL語法介紹-DQL 資料查詢語言</title>
    <url>/2024/01/18/MySQL-SQL%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-DQL-%E8%B3%87%E6%96%99%E6%9F%A5%E8%A9%A2%E8%AA%9E%E8%A8%80/</url>
    <content><![CDATA[<p>DQL(Data Query Language) 資料查詢語言</p>
<span id="more"></span>

<h3 id="基礎查詢資料"><a href="#基礎查詢資料" class="headerlink" title="基礎查詢資料"></a>基礎查詢資料</h3><h4 id="查詢資料"><a href="#查詢資料" class="headerlink" title="查詢資料"></a>查詢資料</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件;</span><br></pre></td></tr></table></figure>

<h4 id="去除重複資料"><a href="#去除重複資料" class="headerlink" title="去除重複資料"></a>去除重複資料</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件;</span><br></pre></td></tr></table></figure>

<h4 id="取別名"><a href="#取別名" class="headerlink" title="取別名"></a>取別名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span> <span class="keyword">AS</span> 別名<span class="number">1</span>, 欄位名<span class="number">2</span> <span class="keyword">AS</span> 別名<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件;</span><br></pre></td></tr></table></figure>

<h3 id="條件查詢"><a href="#條件查詢" class="headerlink" title="條件查詢"></a>條件查詢</h3><h4 id="基本語法"><a href="#基本語法" class="headerlink" title="基本語法"></a>基本語法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件;</span><br></pre></td></tr></table></figure>

<h4 id="條件查詢關鍵字表格"><a href="#條件查詢關鍵字表格" class="headerlink" title="條件查詢關鍵字表格"></a>條件查詢關鍵字表格</h4><table>
<thead>
<tr>
<th>關鍵字</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>&gt;</td>
<td>大於</td>
</tr>
<tr>
<td>&lt;</td>
<td>小於</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>大於等於</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>小於等於</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>等於</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>不等於</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等於</td>
</tr>
<tr>
<td>BETWEEN…AND…</td>
<td>在…之間</td>
</tr>
<tr>
<td>IN(…)</td>
<td>在…群組之中</td>
</tr>
<tr>
<td>LIKE</td>
<td>模糊查詢</td>
</tr>
<tr>
<td>IS NULL</td>
<td>為空值</td>
</tr>
<tr>
<td>IS NOT NULL</td>
<td>不為空值</td>
</tr>
<tr>
<td>AND</td>
<td>且</td>
</tr>
<tr>
<td>OR</td>
<td>或</td>
</tr>
<tr>
<td>NOT</td>
<td>非</td>
</tr>
</tbody></table>
<h4 id="條件查詢範例"><a href="#條件查詢範例" class="headerlink" title="條件查詢範例"></a>條件查詢範例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">200</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">IN</span>(<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> 欄位名<span class="number">2</span> <span class="operator">&lt;</span> <span class="number">200</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">OR</span> 欄位名<span class="number">2</span> <span class="operator">&lt;</span> <span class="number">200</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> <span class="keyword">NOT</span> 欄位名<span class="number">1</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<h4 id="like-模糊查詢介紹"><a href="#like-模糊查詢介紹" class="headerlink" title="like 模糊查詢介紹"></a>like 模糊查詢介紹</h4><p>XX%XX 代表任意長度的字串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%A%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>XX_XX 代表任意一個字元</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 欄位名<span class="number">1</span> <span class="keyword">LIKE</span> <span class="string">&#x27;A_&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="排序查詢"><a href="#排序查詢" class="headerlink" title="排序查詢"></a>排序查詢</h3><h4 id="排序查詢語法"><a href="#排序查詢語法" class="headerlink" title="排序查詢語法"></a>排序查詢語法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 欄位名<span class="number">1</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>, 欄位名<span class="number">2</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>, ...;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有多個欄位，會先以第一個欄位排序，如果第一個欄位有相同的值，再以第二個欄位排序，以此類推</p>
</blockquote>
<h4 id="聚合函數語法"><a href="#聚合函數語法" class="headerlink" title="聚合函數語法"></a>聚合函數語法</h4><table>
<thead>
<tr>
<th>聚合函數</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>COUNT(欄位名)</td>
<td>計算欄位名的總數</td>
</tr>
<tr>
<td>SUM(欄位名)</td>
<td>計算欄位名的總和</td>
</tr>
<tr>
<td>AVG(欄位名)</td>
<td>計算欄位名的平均值</td>
</tr>
<tr>
<td>MAX(欄位名)</td>
<td>計算欄位名的最大值</td>
</tr>
<tr>
<td>MIN(欄位名)</td>
<td>計算欄位名的最小值</td>
</tr>
</tbody></table>
<blockquote>
<p>所有聚合函數都會忽略 NULL 值</p>
</blockquote>
<h4 id="聚合函數範例"><a href="#聚合函數範例" class="headerlink" title="聚合函數範例"></a>聚合函數範例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(欄位名<span class="number">1</span>), <span class="built_in">SUM</span>(欄位名<span class="number">2</span>), <span class="built_in">AVG</span>(欄位名<span class="number">3</span>), <span class="built_in">MAX</span>(欄位名<span class="number">4</span>), <span class="built_in">MIN</span>(欄位名<span class="number">5</span>) <span class="keyword">FROM</span> 資料表名;</span><br></pre></td></tr></table></figure>

<h4 id="分組查詢語法"><a href="#分組查詢語法" class="headerlink" title="分組查詢語法"></a>分組查詢語法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 聚合函數<span class="number">1</span>, 聚合函數<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 欄位名<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="分組查詢範例-搭配-where"><a href="#分組查詢範例-搭配-where" class="headerlink" title="分組查詢範例(搭配 where)"></a>分組查詢範例(搭配 where)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 聚合函數<span class="number">1</span>, 聚合函數<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 欄位名<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="分組查詢範例-搭配-having"><a href="#分組查詢範例-搭配-having" class="headerlink" title="分組查詢範例(搭配 having)"></a>分組查詢範例(搭配 having)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 聚合函數<span class="number">1</span>, 聚合函數<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 <span class="keyword">GROUP</span> <span class="keyword">BY</span> 欄位名<span class="number">1</span> <span class="keyword">HAVING</span> 條件;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>執行順序: WHERE -&gt; 聚合函數 -&gt; HAVING</p>
</blockquote>
<h4 id="分頁查詢語法"><a href="#分頁查詢語法" class="headerlink" title="分頁查詢語法"></a>分頁查詢語法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ... <span class="keyword">FROM</span> 資料表名 LIMIT 起始位置, 查詢筆數;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>起始索引計算方式&#x3D; (頁數 - 1) * 每頁筆數</p>
</blockquote>
<h4 id="分頁查詢範例"><a href="#分頁查詢範例" class="headerlink" title="分頁查詢範例"></a>分頁查詢範例</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 資料表名 LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>LIMIT 是 MySQL 的語法，不是標準 SQL 語法，不同的資料庫可能會有不同的寫法</p>
</blockquote>
<h3 id="DQL-小結"><a href="#DQL-小結" class="headerlink" title="DQL 小結"></a>DQL 小結</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ...</span><br><span class="line"><span class="keyword">FROM</span> 資料表名</span><br><span class="line"><span class="keyword">WHERE</span> 條件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 欄位名<span class="number">1</span></span><br><span class="line"><span class="keyword">HAVING</span> 條件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 欄位名<span class="number">1</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>, 欄位名<span class="number">2</span> <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span>, ...</span><br><span class="line">LIMIT 起始位置, 查詢筆數;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-SQL語法介紹-DML 資料定義語言</title>
    <url>/2024/01/18/MySQL-SQL%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-DML-%E8%B3%87%E6%96%99%E6%93%8D%E4%BD%9C%E8%AA%9E%E8%A8%80/</url>
    <content><![CDATA[<p>DML(Data Manipulation Language) 資料操作語言</p>
<span id="more"></span>

<h4 id="給指定欄位新增資料"><a href="#給指定欄位新增資料" class="headerlink" title="給指定欄位新增資料"></a>給指定欄位新增資料</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 資料表名(欄位名<span class="number">1</span>, 欄位名<span class="number">2</span>, ...) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure>

<h4 id="修改資料"><a href="#修改資料" class="headerlink" title="修改資料"></a>修改資料</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 資料表名 <span class="keyword">SET</span> 欄位名<span class="number">1</span><span class="operator">=</span>值<span class="number">1</span>, 欄位名<span class="number">2</span><span class="operator">=</span>值<span class="number">2</span>, ... <span class="keyword">WHERE</span> 條件;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WHERE 條件可以不寫，但是如果不寫，會將資料表所有資料都修改</p>
</blockquote>
<h4 id="刪除資料"><a href="#刪除資料" class="headerlink" title="刪除資料"></a>刪除資料</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 資料表名 <span class="keyword">WHERE</span> 條件;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WHERE 條件可以不寫，但是如果不寫，會將資料表所有資料都刪除</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-SQL語法介紹-DDL 資料定義語言</title>
    <url>/2024/01/18/MySQL-SQL%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9-DDL%20%E8%B3%87%E6%96%99%E5%AE%9A%E7%BE%A9%E8%AA%9E%E8%A8%80/</url>
    <content><![CDATA[<p>DDL(Data Definition Language) 資料定義語言</p>
<span id="more"></span>

<h3 id="操作資料庫"><a href="#操作資料庫" class="headerlink" title="操作資料庫"></a>操作資料庫</h3><p>####查詢資料庫</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure>

<p>####新增資料庫</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE 資料庫名;</span><br></pre></td></tr></table></figure>

<p>####刪除資料庫</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE 資料庫名;</span><br></pre></td></tr></table></figure>

<p>####使用資料庫</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE 資料庫名;</span><br></pre></td></tr></table></figure>

<p>####查看目前使用的數據庫</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br></pre></td></tr></table></figure>

<h3 id="操作資料表"><a href="#操作資料表" class="headerlink" title="操作資料表"></a>操作資料表</h3><h4 id="查詢所有資料表"><a href="#查詢所有資料表" class="headerlink" title="查詢所有資料表"></a>查詢所有資料表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br></pre></td></tr></table></figure>

<h4 id="查詢資料表結構"><a href="#查詢資料表結構" class="headerlink" title="查詢資料表結構"></a>查詢資料表結構</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESC</span> 資料表名;</span><br></pre></td></tr></table></figure>

<h4 id="新增資料表"><a href="#新增資料表" class="headerlink" title="新增資料表"></a>新增資料表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 資料表名(</span><br><span class="line">    欄位名<span class="number">1</span> 資料型態<span class="number">1</span>,</span><br><span class="line">    欄位名<span class="number">2</span> 資料型態<span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="刪除資料表"><a href="#刪除資料表" class="headerlink" title="刪除資料表"></a>刪除資料表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 資料表名;</span><br></pre></td></tr></table></figure>

<h4 id="修改資料表"><a href="#修改資料表" class="headerlink" title="修改資料表"></a>修改資料表</h4><p>####修改資料表名稱</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 資料表名 RENAME 新資料表名;</span><br></pre></td></tr></table></figure>

<p>####新增欄位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 資料表名 <span class="keyword">ADD</span> 欄位名 資料型態;</span><br></pre></td></tr></table></figure>

<p>####修改資料類型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 資料表名 MODIFY 欄位名 新資料型態;</span><br></pre></td></tr></table></figure>

<p>####修改資料表欄位名稱和資料類型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 資料表名 CHANGE 欄位名 新欄位名 新資料型態;</span><br></pre></td></tr></table></figure>

<p>####刪除欄位</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 資料表名 <span class="keyword">DROP</span> 欄位名;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>React Hook-useMemo</title>
    <url>/2024/01/11/React-Hook-useMemo/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根據 React 官方文件中的說明，useMemo 會在渲染期間記住傳入的函式，並且在渲染期間避免重複執行該函式。</p>
<span id="more"></span>

<h3 id="什麼時候使用-useMemo"><a href="#什麼時候使用-useMemo" class="headerlink" title="什麼時候使用 useMemo"></a>什麼時候使用 useMemo</h3><p>官方文件也強調你應該僅僅把 useMemo 作為性能優化的手段。如果沒有它，你的程式碼就不能正常運作，那麼請先找到潛在的問題並修復它。然後再添加 useMemo 以提高性能。</p>
<h3 id="useMemo-的使用方式"><a href="#useMemo-的使用方式" class="headerlink" title="useMemo 的使用方式"></a>useMemo 的使用方式</h3><p>useMemo(calculateValue, dependencies)<br>calculateValue:裡頭帶一個 callback 並寫入需要處理的函式<br>dependencies:依賴的值，當這個值改變時，useMemo 才會重新執行</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">add</span>(countA);</span><br><span class="line">&#125;, [countA]);</span><br></pre></td></tr></table></figure>

<h3 id="useMemo-的使用場景"><a href="#useMemo-的使用場景" class="headerlink" title="useMemo 的使用場景"></a>useMemo 的使用場景</h3><p>如下方的例子，如果沒有使用 useMemo，當我們點擊 countB 按鈕時，同樣會執行 add 函式，但是我們只想要 countA 改變時才執行 add 函式，因為我們只在乎 result 的結果而在下方範例中 result 又只有跟 countA 有關係，這時候就可以使用 useMemo 來避免重複執行 add 函式。</p>
<p>但是附帶一提，其實沒有使用 useMemo 也不會有什麼問題，因為 就頂多是重複執行 add 函式而已，但是如果 add 函式是一個很耗時的函式，那麼就會造成效能上的問題，這時候就可以使用 useMemo 來避免重複執行 add 函式。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我被執行了&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [countA, setCountA] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [countB, setCountB] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">add</span>(countA);</span><br><span class="line">  &#125;, [countA]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCountA((countA) =&gt; countA + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        count is &#123;countA&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          setCountB((countB) =&gt; countB + 1);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        count is &#123;countB&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Hook</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 30 遲來的完賽</title>
    <url>/2024/01/09/Day%2030%20%E9%81%B2%E4%BE%86%E7%9A%84%E5%AE%8C%E8%B3%BD/</url>
    <content><![CDATA[<p>該給這系列一個交代，去年還在資策會進行培訓，正好在學習 React，看到鐵人賽的活動，就想說來試試看，但是沒想到有點高估自己的能力，到了最後專題的時刻忙得不可開交，在時間分配上沒做好拿捏而停賽了，雖然如此但一職還是想把這個系列補完，但一連串忙下來，回過神來就已經開始在職場上工作了，所以就一直拖到現在，現在終於有時間可以把這個系列補完了，去年的目標也算是達成了吧~</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 29 React的本質-Library</title>
    <url>/2024/01/02/Day%2029%20React%E7%9A%84%E6%9C%AC%E8%B3%AA-Library/</url>
    <content><![CDATA[<p>雖然 React 現在被稱作 3 大框架其中之一，但是如果現在打開 React 的官網，會發現它的定位是一個 Library，而不是一個 Framework，事實上 React 確實保持著高度靈活性，讓開發者可以自由的選擇其他的 Library 來搭配使用，這也是為什麼 React 能夠在短短幾年內就成為主流的原因之一。甚至在搭配的套件上也有許多不同的選擇，像是 Redux、React-Router、React-Bootstrap 等等，這些套件都是為了滿足不同的需求而生的，而且都是由社群開發的，這也意味著 React 的生態系非常的豐富，而且也有許多的資源可以參考，這也是 React 能夠快速成長的原因之一。今天就來試著用一個簡單的例子來說明 React 的本質吧!</p>
<span id="more"></span>

<h3 id="使用-CDN-引用-React"><a href="#使用-CDN-引用-React" class="headerlink" title="使用 CDN 引用 React"></a>使用 CDN 引用 React</h3><p>跟許多其他的 Library 一樣，React 也可以透過 CDN 的方式來引用，這樣就不需要透過 npm 或是 yarn 來安裝，，只需要在 HTML 中引用 React 的 CDN 就可以使用了，以下是範例，可以直接複製貼上到 HTML 中，然後用套件 liveserver 打開就可以看到 console 結果了。可以看到 React 跟 ReactDOM 可以是使用的方法，而且還有 babel，這是因為 React 的語法是 JSX，所以需要 babel 來轉換成 JavaScript 才能執行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;rrot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">React</span>, <span class="title class_">ReactDOM</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="React-CDN-使用範例"><a href="#React-CDN-使用範例" class="headerlink" title="React CDN 使用範例"></a>React CDN 使用範例</h3><p>接續上一個例子，這次就來試著使用 React 的元件吧!首先要先創造一個元件，然後再把它渲染到 root 根元素上，以下是範例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@18/umd/react.development.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">crossorigin</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 創造元件</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> (</span></span><br><span class="line"><span class="language-javascript">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">        );</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 把App元件渲染至root根元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>大家可以發現，我這裡只是單純的使用 HTML 而已，並沒有使用太複雜的環境建置工具，雖然實務上不會這樣使用，但是我這裡只是想要表達 React 並不是那麼的難以接近，在官方定義成 library 的前提下，至少在一開始的學習上心態上可以抱持輕鬆一點的態度，不用太過於緊張。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>window&amp;body</title>
    <url>/2023/12/29/window-body/</url>
    <content><![CDATA[<h2 id="文字版"><a href="#文字版" class="headerlink" title="文字版"></a>文字版</h2><p>在 JavaScript 中，window 和 document.body 是兩個重要的全局物件，它們代表瀏覽器視窗和網頁文件的主體部分。讓我們來看一下它們之間的差異：</p>
<span id="more"></span>

<ol>
<li>window：</li>
</ol>
<ul>
<li>window 是瀏覽器中的全局物件，代表整個瀏覽器視窗。</li>
<li>它是所有全局變數和函式的最高級別的容器，可以透過它來訪問和操作全局範圍的變數和函式。</li>
<li>它提供了許多瀏覽器相關的屬性和方法，比如 window.location 可以用來獲取當前網址，window.alert() 可以用來顯示警告對話框，等等。</li>
</ul>
<ol start="2">
<li>document.body：</li>
</ol>
<ul>
<li>document.body 是 document 物件的一部分，代表 HTML 文件的主體部分。</li>
<li>它表示網頁中的 <body> 元素，即網頁中的主要內容區域。 *透過 document.body 可以訪問和操作網頁主體中的元素，例如透過 document.body.appendChild(element) 可以將元素添加到主體中。</li>
</ul>
<p>總結來說，window 是瀏覽器視窗的全局物件，而 document.body 是 HTML 文件的主體部分。它們都提供了許多功能來處理瀏覽器和網頁的相關操作。在網頁開發中，你會經常使用這兩個物件來操作網頁和處理事件。</p>
<h2 id="表格整理版"><a href="#表格整理版" class="headerlink" title="表格整理版"></a>表格整理版</h2><p>當前瀏覽器視窗和網頁文件主體的差異如下：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>window</code></th>
<th><code>document.body</code></th>
</tr>
</thead>
<tbody><tr>
<td>定義位置</td>
<td>全局範圍（在所有地方可訪問）</td>
<td><code>document</code> 物件的一部分（HTML 文件內）</td>
</tr>
<tr>
<td>代表的物件</td>
<td>瀏覽器視窗</td>
<td>HTML 文件的主體部分（<code>&lt;body&gt;</code> 元素）</td>
</tr>
<tr>
<td>功能</td>
<td>提供瀏覽器相關的屬性和方法</td>
<td>提供操作網頁主體內容的屬性和方法</td>
</tr>
<tr>
<td>例子</td>
<td><code>window.location</code></td>
<td><code>document.body.appendChild(element)</code></td>
</tr>
<tr>
<td>使用場景</td>
<td>瀏覽器操作、全局變數和函式</td>
<td>操作網頁內容、處理網頁事件</td>
</tr>
</tbody></table>
<p><code>window</code> 物件是瀏覽器中的全局物件，它提供了許多瀏覽器相關的屬性和方法，可以在任何地方訪問。而 <code>document.body</code> 則是 <code>document</code> 物件的一部分，代表 HTML 文件的主體部分，主要用於操作網頁主體內容，例如添加元素或處理事件。在網頁開發中，你會經常使用這兩個物件來處理瀏覽器和網頁的相關操作。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>在 html 使用 ejs 的方法</title>
    <url>/2023/12/29/use-ejs-in-html/</url>
    <content><![CDATA[<h3 id="ejs-常用簡單語法介紹"><a href="#ejs-常用簡單語法介紹" class="headerlink" title="ejs 常用簡單語法介紹"></a>ejs 常用簡單語法介紹</h3><p>1.撰寫程式邏輯</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="string">&quot;這裡寫程式邏輯&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>2.傳遞參數</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%= <span class="string">&quot;傳遞參數&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>3.傳遞 HTML 語法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%- <span class="string">&quot;傳遞HTML語法&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>&lt;%&#x3D; %&gt; 和 &lt;%- %&gt;差別<br>“&#x3D;”:會完整傳遞<br>“-“:它看得懂 HTML 語法</p>
<p>4.匯入 ejs:有兩個參數<br>第一個參數是路徑<br>第二個參數是要傳進去的變數要用物件包起來，有點像 React 的 Props</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;%- <span class="title function_">include</span>(<span class="string">&quot;./layout/test&quot;</span>,&#123;element,id&#125;) %&gt;</span><br></pre></td></tr></table></figure>

<h3 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h3><p>1.ejs 模板</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//檔名:test.ejs</span></span><br><span class="line">&lt;h1&gt;hello world &lt;%= element %&gt;&lt;%= id %&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>2.要寫的 html，只列 body</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;% <span class="keyword">let</span> name=[<span class="string">&quot;Robin&quot;</span>,<span class="string">&quot;Amy&quot;</span>,<span class="string">&quot;Ann&quot;</span>] %&gt;<span class="comment">//這裡是定義變數，未來可能會打API存在這</span></span><br><span class="line">&lt;% name.<span class="title function_">map</span>(<span class="function">(<span class="params">element,id</span>)=&gt;</span> &#123; %&gt;<span class="comment">//因為中間要塞這個可以轉譯HTML的語法，所以拆開來寫</span></span><br><span class="line">&lt;%- <span class="title function_">include</span>(<span class="string">&quot;./layout/test&quot;</span>,&#123;element,id&#125;) %&gt;<span class="comment">//匯入剛剛的ejs模板並帶入變數</span></span><br><span class="line">&lt;% &#125;); %&gt;<span class="comment">//因為中間要塞這個可以轉譯HTML的語法，所以拆開來寫</span></span><br></pre></td></tr></table></figure>

<p>3.完成結果如下<br><img src="https://i.imgur.com/B91Jqx1.png"></p>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>ejs</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 28 React 的 Hello World-Hook-useState</title>
    <url>/2023/10/12/Day%2028%20React%E7%9A%84Hello%20World-Hook-useState/</url>
    <content><![CDATA[<p>要說 React 有什麼特別的地方我覺得應該就是 HooK 了吧!Hook 是在 React 16.8 版中加入的，hook 有很多種，每一種的功能都不太一樣，甚至還可以自定義，簡單來說它就是函式，然後可以重複一直使用。但其實這是一個有點抽象的概念，所以就直接從實際的例子來了解吧!</p>
<span id="more"></span>

<h2 id="什麼是-useState"><a href="#什麼是-useState" class="headerlink" title="什麼是 useState?"></a>什麼是 useState?</h2><p>這是 React 最基本的一個 hook 之一，它的作用是儲存某個變數的狀態；並設定更新它的方法，基本寫法如下:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [變數名稱, set變數名稱] = <span class="title function_">useState</span>(初始值);</span><br></pre></td></tr></table></figure>

<p>有三點需要注意: 1.需要依照小駝峰的規則撰寫 2.盡量給初始值，也就是變數名稱最一開始的狀態 3.變數只能被 set 變數做改變，使用方法就是在裡面塞一個更新後的數值</p>
<p>以下舉個例子:</p>
<p>宣告一個名為 count 的變數，此變數只能透過 setCount 做改變，且初始值為 0</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">setCount</span>(<span class="number">1</span>); <span class="comment">//更新此變數為1</span></span><br></pre></td></tr></table></figure>

<h2 id="useState-的作用"><a href="#useState-的作用" class="headerlink" title="useState 的作用?"></a>useState 的作用?</h2><p>因為在 React 中，不應該直接修改元件函式內部的變數，因為這不會觸發重新渲染元件。必須要使用 React 提供的狀態管理來處理這類情況，所以下面的例子:來展示其中差異</p>
<p>1.沒使用 useState:畫面的按鈕會沒有作用</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          a = a + 1;</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        按鈕</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>現在數值:&#123;a&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>2.使用 useState:才能改變狀態</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [a, setA] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleIncrement</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setA</span>(a + <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleIncrement&#125;</span>&gt;</span>按鈕<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>現在數值: &#123;a&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>在 React 中與畫面有關的變數都需要 useState 來做一個所謂的狀態管理，才能觸發重新渲染畫面，而且這個變數只能透過跟它同組宣告變數的方法做改變。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 27 React 的純函數元件</title>
    <url>/2023/10/11/Day%2027%20React%E7%9A%84%E7%B4%94%E5%87%BD%E6%95%B8%E5%85%83%E4%BB%B6/</url>
    <content><![CDATA[<p>今天要解釋的東西會比較無聊乏味一點，但在 React 元件化導向的框架裡卻是一個很重要的概念，因為元件具有可以重複使用的特性，所以如果不是純函示會有一些 Bug 存在。</p>
<span id="more"></span>

<h2 id="純函式的特性"><a href="#純函式的特性" class="headerlink" title="純函式的特性"></a>純函式的特性</h2><p>純函式是一個在軟體開發中的重要概念，它有以下主要特點：</p>
<ol>
<li><p><strong>相同的輸入始終產生相同的輸出：</strong> 當你將相同的輸入值傳遞給一個純函式時，它始終會返回相同的輸出，不受外部狀態的影響。這種可預測性對於測試和除錯非常重要，因為你可以確信函式的行為不會因為外部狀態的改變而變化。</p>
</li>
<li><p><strong>不會修改外部狀態：</strong> 純函式不會修改或影響除了它的輸入參數以外的任何狀態。這意味著它不會修改全域變數、不會修改傳遞給它的物件或陣列，也不會修改任何外部狀態。</p>
</li>
<li><p><strong>沒有副作用：</strong> 純函式不會引起任何副作用，如改變資料庫的數據、發送 HTTP 請求、修改文件系統等。它僅僅是通過計算返回一個值。</p>
</li>
<li><p><strong>可組合性：</strong> 由於純函式不依賴於外部狀態，它們非常容易組合在一起建構更複雜的邏輯。這種特性使得代碼更容易維護、測試和重用。</p>
</li>
</ol>
<p>解釋了那麼多，我相信大家看了眼睛都花了而且一頭霧水，簡單舉例如下:<br>這就是一個純函式，不會修改外部狀態、沒有副作用、相同輸入有相同輸出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個 <code>add</code> 函式是純函式，因為它始終返回相同的輸出（兩個數字的和），不修改外部狀態，也不產生副作用。</p>
<p>那不是純函式又會發生什麼事呢?範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addToTotal</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  total += num;</span><br><span class="line">  <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addToTotal</span>(<span class="number">3</span>)); <span class="comment">// 第一次呼叫，返回 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addToTotal</span>(<span class="number">3</span>)); <span class="comment">// 第二次呼叫，返回 6</span></span><br></pre></td></tr></table></figure>

<p>這就不是一個純函式，因為它會改變外部狀態而且，相同的輸入得到不同的輸出。</p>
<p>那想一想如果它是一個元件，我們重複使用三次會發生什麼事?<br>範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AddToTotal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  total += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;total&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>引入第一次<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AddToTotal</span> /&gt;</span> //2</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>引入第二次<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AddToTotal</span> /&gt;</span> //4</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>引入第三次<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">AddToTotal</span> /&gt;</span> //6</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>就會發現明明就是引入同一個元件，但是會產生不同的結果，這會在重複使用這個元件特性上，造成無法預期的錯誤，所以 react 會鼓勵元件的寫法都要以純函式為主。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然無聊或是繁瑣，但是如果發生想不到的錯誤就來檢查看看是不是純函式的問題，但後續其實有相對應的解法，但也續本系列不會提到，但是不純的函式在 react 元件中應該盡量被避免的。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 26 React 的多重渲染-列表與 Key</title>
    <url>/2023/10/10/Day%2026%20React%E7%9A%84%E5%A4%9A%E9%87%8D%E6%B8%B2%E6%9F%93-%E5%88%97%E8%A1%A8%E8%88%87Key/</url>
    <content><![CDATA[<p>在 react 使用遍歷陣列的方法來呈現畫面是挺常見的，我們今天想要呈現一個陣列裡面的資料如下:</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const tasks = [</span><br><span class="line">  &#123; id: 1, text: &quot;看完 React的文件 &quot; &#125;,</span><br><span class="line">  &#123; id: 2, text: &quot;寫一篇部落格文章&quot; &#125;,</span><br><span class="line">  &#123; id: 3, text: &quot;學習 JavaScript&quot; &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>基本上我們不可能一個一個複製貼上，所以會利用 JSX 的 JavaScript 方法，去讀取資料並呈現畫面，有點像是 PHP 那樣的感覺。看範例寫法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> tasks = [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&quot;看完 React的文件 &quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&quot;寫一篇部落格文章&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">text</span>: <span class="string">&quot;學習 JavaScript&quot;</span>&#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的任務清單<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;tasks.map((task) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;task.id&#125;</span>&gt;</span>&#123;task.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>上面的範例是使用 map 的方法，不過這裡使用 forEach 也可以，差異是 map 會回傳新陣列但是 forEach 不會，至於 React 中為什麼會慣用 map 的原因與 hook 中的 useState 有關，這裡就先不多做贅述。</p>
<h3 id="key-值的作用"><a href="#key-值的作用" class="headerlink" title="key 值的作用"></a>key 值的作用</h3><p>仔細看上述的程式碼，會發現與正常遍歷陣列的方法不同的是多了一個 Key 值，它的作用是讓 react 能區別每一筆資料，雖然如果不給 key 值 react 會預設 index 當作 key 值，但是這不是一個好的寫法，因為可能會產生不穩定性(像是在對陣列操作增加、刪除之類的)，造成渲染畫面的不確定性。</p>
<p>所以設定 key 值需要注意以下條件: 1.唯一性 2.必須從外部設定，不要再遍歷函示產生 3.不能隨意地被改變</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以上就是渲染陣列物件基本的方法，而且會與後續在使用 Hook 的順暢度會有直接的關係。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官方網站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 25 React 的選擇渲染-JSX 與條件控制的關係</title>
    <url>/2023/10/08/Day%2025%20React%E7%9A%84%E9%81%B8%E6%93%87%E6%B8%B2%E6%9F%93-JSX%E8%88%87%E6%A2%9D%E4%BB%B6%E6%8E%A7%E5%88%B6%E7%9A%84%E9%97%9C%E4%BF%82/</url>
    <content><![CDATA[<p>說到 JavaScript 的流程控制大家很容易聯想到 if…else…或是三元運算子，在 JSX 裡面可以利用這些流程控制來選選擇性的呈現想要渲染的畫面。</p>
<p>官網分別介紹三種:<br>1.if..else 2.三元運算子(條件式 ? True 的結果 :False 的結果) 3.邏輯運算子(&amp;&amp;)</p>
<span id="more"></span>

<h2 id="用-if…else-控制元件出現"><a href="#用-if…else-控制元件出現" class="headerlink" title="用 if…else..控制元件出現"></a>用 if…else..控制元件出現</h2><p>這我相信能看到這裡的，大家都對這個語法很熟，但在 React 寫法就變成下面這樣，如果 number&#x3D;”A”就會 return 並渲染 “AAA”，除此之外會 return 並渲染 “BBB”。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (number === <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="條件運算子"><a href="#條件運算子" class="headerlink" title="條件運算子"></a>條件運算子</h2><p>ES6 的語法，簡單來說就是 if else 的簡化版，但是略有些差異以及特性，這裡就不先多提，因為在這裡兩者幾乎是等效的。<br>它由一個?和:組成基本架構如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">條件式 ? 條件式為真要輸出的結果 : 條件式為假的時候要輸出的結果;</span><br></pre></td></tr></table></figure>

<p>如果更改上述的範例為三元運算子的寫法如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  let number = &quot;A&quot;;</span><br><span class="line">  return number === &quot;A&quot; ? &lt;h1&gt;AAA&lt;/h1&gt; : &lt;h1&gt;BBB&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或是這樣</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  let number = &quot;A&quot;;</span><br><span class="line">  return (</span><br><span class="line">  &lt;&gt;</span><br><span class="line">  &#123;number === &quot;A&quot; ? &lt;h1&gt;AAA&lt;/h1&gt; : &lt;h1&gt;BBB&lt;/h1&gt;&#125;</span><br><span class="line">  &lt;/&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>看起來更為簡單一點，可是在對於剛接觸的人比較不容易閱讀，要注意的一點</p>
<blockquote>
<p>三元運算子是運算子它不是陳述式所以可以寫在 jsx 的{}裡，但是 if…else 則不行</p>
</blockquote>
<h2 id="邏輯運算子"><a href="#邏輯運算子" class="headerlink" title="邏輯運算子(&amp;&amp;)"></a>邏輯運算子(&amp;&amp;)</h2><p>這部分的寫法就更為簡單一點，但是適用的情況也不太一樣，比較適用決定是否要呈現元件，而不是選擇性呈現，寫法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default function App() &#123;</span><br><span class="line">  return &lt;&gt;&#123;true &amp;&amp; &lt;h1&gt;AAA&lt;/h1&gt;&#125; &lt;/&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然這三種寫法都是在做元件的選擇性渲染，但其實每一種方法適用的情境略有不同，需要依照適合的狀況，選擇適合的寫法:</p>
<ul>
<li>使用 if…else 時，可以處理較複雜的條件邏輯。</li>
<li>三元運算子 提供了簡潔的寫法，適用於簡單的條件選擇。</li>
<li>邏輯運算子 (&amp;&amp;) 適合單一條件，不需要額外 else 或 return null。</li>
</ul>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官方網站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 23 React 中的 JavaScript</title>
    <url>/2023/10/07/Day%2023%20React%E4%B8%AD%E7%9A%84JavaScript/</url>
    <content><![CDATA[<p>今天要介紹的是 JSX 重要的部分，就是如何在 JSX 中寫 JavaScript，其實很理所當然的 JSX 來就是 JavaScript，所以能寫 JavaScript 是一件蠻合理的一件事情，但依然有些規則需要遵守。接下來就依序來介紹吧!</p>
<span id="more"></span>

<h3 id="1-使用大括號-處理-Javascript"><a href="#1-使用大括號-處理-Javascript" class="headerlink" title="1.使用大括號{}處理 Javascript"></a>1.使用大括號{}處理 Javascript</h3><p>(1) 像是變數或是函式都可以在大括號裡被使用舉例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;AAA&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>My name is &#123;name&#125; <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>(2) 大括號的使用範圍</p>
<ul>
<li>標籤內的文本</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;<span class="title class_">My</span> name is &#123;name&#125; &lt;/p&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>在&#x3D;後面的屬性</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;src=&#123;picture&#125; img/&gt;<span class="comment">//pictrue可能為一個變數</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用-CSS-inline-styles"><a href="#2-使用-CSS-inline-styles" class="headerlink" title="2.使用 CSS inline styles"></a>2.使用 CSS inline styles</h3><p>需要使用兩層大括號，第一層是 JSX 要使用 JavaScript 規定的;第二層是因為 inline styles 被當作一個物件傳遞所以有大括號</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;p style=&#123;&#123;<span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">backgroundColor</span>: <span class="string">&quot;black&quot;</span>&#125;&#125;&gt;<span class="title class_">My</span> name is &#123;name&#125; &lt;/p&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-在大括弧中放表達式，不能陳述式"><a href="#3-在大括弧中放表達式，不能陳述式" class="headerlink" title="3.在大括弧中放表達式，不能陳述式"></a>3.在大括弧中放表達式，不能陳述式</h3><p>首先來複習一下什麼式表達式，可回傳一個結果的程式片斷就是一個表達式簡單來說，下列就是一個表達式，因為 console.log 會回傳 3</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>為什麼會突然提這個呢?因為常用流程控制 if else 就是陳述式，所以這樣寫會報錯的喔!下面就是一個很經典的例子，這裡先留一個梗後續的文章會在說明，簡單來說三元運算子不是陳述式。</p>
<ul>
<li>錯誤示範</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> b =<span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="keyword">const</span> judge = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;if(judge)&#123;</span></span><br><span class="line"><span class="language-xml">        &#123;a&#125;</span></span><br><span class="line"><span class="language-xml">      &#125;else&#123;</span></span><br><span class="line"><span class="language-xml">        &#123;b&#125;</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>正確示範</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="string">&quot;true&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="string">&quot;false&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> judge = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>&#123;judge ? a : b&#125;<span class="tag">&lt;/&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>今天的重點其實很簡單，要寫 JavaScript 就在{}裡面寫就對了，但不能寫陳述式。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 24 React 的橋樑-Prpos</title>
    <url>/2023/10/07/Day%2024%20React%E7%9A%84%E6%A9%8B%E6%A8%91-Prpos/</url>
    <content><![CDATA[<h1 id="Day24-React-的橋樑-Prpos"><a href="#Day24-React-的橋樑-Prpos" class="headerlink" title="Day24 React 的橋樑-Prpos"></a>Day24 React 的橋樑-Prpos</h1><p>Props 是一個元件之間傳遞資料的手段，它其實有點像是 HTML 標籤的屬性，實際上很多像是 HTML 標籤的屬性也被預設為 Props，例如 img 標籤的 src,alt 等等，但也可以自定義，有點像是 data-set 那樣，接下來就開始今天的主題吧!</p>
<span id="more"></span>

<h2 id="Props-的特性"><a href="#Props-的特性" class="headerlink" title="Props 的特性"></a>Props 的特性</h2><h4 id="1-只能允許單向資料流"><a href="#1-只能允許單向資料流" class="headerlink" title="1.只能允許單向資料流"></a>1.只能允許單向資料流</h4><p>簡單來說就是只能從父元件傳到子元件，要從子元件傳回去需要用其它特殊方法</p>
<h4 id="2-資料類型為物件"><a href="#2-資料類型為物件" class="headerlink" title="2.資料類型為物件"></a>2.資料類型為物件</h4><h4 id="3-不可被元件本身自己改變"><a href="#3-不可被元件本身自己改變" class="headerlink" title="3.不可被元件本身自己改變"></a>3.不可被元件本身自己改變</h4><h4 id="4-但可以被父元件改變"><a href="#4-但可以被父元件改變" class="headerlink" title="4.但可以被父元件改變"></a>4.但可以被父元件改變</h4><h4 id="5-可以自訂預設值，父元件如果沒給定值會自行套用"><a href="#5-可以自訂預設值，父元件如果沒給定值會自行套用" class="headerlink" title="5.可以自訂預設值，父元件如果沒給定值會自行套用"></a>5.可以自訂預設值，父元件如果沒給定值會自行套用</h4><h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><p>1.將 props 傳給子元件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Child</span> test=<span class="string">&quot;AAA&quot;</span> num=&#123;<span class="number">100</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>2.在子元件讀取傳遞的值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Child</span>(&#123;test, num&#125;);</span><br></pre></td></tr></table></figure>

<p>3.可以自訂預設參數</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Child</span> test=<span class="string">&quot;AAA&quot;</span> num=&#123;<span class="number">100</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h3 id="總結程式"><a href="#總結程式" class="headerlink" title="總結程式"></a>總結程式</h3><p>父元件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&quot;./child&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>啟用預設值<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>父元件改變props<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Child</span> <span class="attr">test</span>=<span class="string">&quot;AAA&quot;</span> <span class="attr">num</span>=<span class="string">&#123;100&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子元件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123; test = <span class="string">&quot;BBB&quot;</span>, num = <span class="number">10</span>//自訂預設值&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>text: &#123;test&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>num: &#123;num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="props-傳遞參數的解構賦值"><a href="#props-傳遞參數的解構賦值" class="headerlink" title="props 傳遞參數的解構賦值"></a>props 傳遞參數的解構賦值</h3><p>事實上，上述的範例已經也在使用了，在一開始就提到 Props 是一個物件，如果照最原始的寫法應該如下，所以重頭到尾都只傳遞一個名為 props 物件的參數而已。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h4</span>&gt;</span>Child<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>text: &#123;props.test&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>num: &#123;props.num&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ESLint-處理"><a href="#ESLint-處理" class="headerlink" title="ESLint 處理"></a>ESLint 處理</h3><p>PS:如果遇到”is missing in props validation”<br>在.eslintrc.cjs 的 rules 加上下面這段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;react/prop-types&quot;: &quot;off&quot;,</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>props 使用起來蠻直覺的，但是有其限制所在，如果需要更進一步的活用，要了解更後面的內容包刮 Hook 之類的內容，基本上在這著系列應該沒有什麼機會介紹到，畢竟是入門向的文章，如果有機會後續再作補充，明天就會介紹到比較偏向實作的內容了。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官方網站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 22 React 的語法-JSX</title>
    <url>/2023/10/06/Day%2022%20React%E7%9A%84%E8%AA%9E%E6%B3%95-JSX/</url>
    <content><![CDATA[<p>JSX 為 React 的語法，簡單的來說就是可以使用 JavaScript 來撰寫 HTML 標籤，然而官方文件也有提到，不用 JSX 也是可以，但多數的 React 開發者鑑於 JSX 便利性還是會選擇 JSX 語法，事實上也是如此 JSX 帶給我們許多方便的體驗，但相對的需要遵守一些規則。</p>
<span id="more"></span>

<h2 id="JSX-的規則"><a href="#JSX-的規則" class="headerlink" title="JSX 的規則"></a>JSX 的規則</h2><h3 id="1-JSX-的語法最外層只能有一個根元素"><a href="#1-JSX-的語法最外層只能有一個根元素" class="headerlink" title="1. JSX 的語法最外層只能有一個根元素"></a>1. JSX 的語法最外層只能有一個根元素</h3><p>這部份昨天也有稍微提到了，原因是因為到底 JSX 還是 JavaScript，而一個函式只能傳回一個東西而已。就像下面的例子，在怎麼樣複雜最外面一層等只會有一個根元素，通常是 div 標籤或是&lt;&gt;&lt;&#x2F;&gt;(Fragment)</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>132<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>132<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>132<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2-標籤需要自閉合"><a href="#2-標籤需要自閉合" class="headerlink" title="2.標籤需要自閉合"></a>2.標籤需要自閉合</h3><p>說穿了就是在只有單一標籤的後方加上&#x2F;這樣舉例如下:</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;img/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span>/&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-使用小駝峰式命名給標籤的屬性名稱，舉例如下的-className"><a href="#3-使用小駝峰式命名給標籤的屬性名稱，舉例如下的-className" class="headerlink" title="3.使用小駝峰式命名給標籤的屬性名稱，舉例如下的 className"></a>3.使用小駝峰式命名給標籤的屬性名稱，舉例如下的 className</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;img src=&#123;reactLogo&#125; className=<span class="string">&quot;logo react&quot;</span> alt=<span class="string">&quot;React logo&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Note"><a href="#Note" class="headerlink" title="Note:"></a>Note:</h4><p>因為 class 為保留字，所以在 JSX 中 class 就寫成<strong>className</strong>;同理 for 寫成<strong>htmlFor</strong></p>
<h3 id="4-布林值-null-undefined-不會被渲染"><a href="#4-布林值-null-undefined-不會被渲染" class="headerlink" title="4.布林值,null,undefined 不會被渲染"></a>4.布林值,null,undefined 不會被渲染</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;&gt;</span><br><span class="line">  不會被渲染</span><br><span class="line">  &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;false&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;null&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;undefined&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-元件事件處理函式需要小駝峰"><a href="#5-元件事件處理函式需要小駝峰" class="headerlink" title="5.元件事件處理函式需要小駝峰"></a>5.元件事件處理函式需要小駝峰</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;&#125;&gt;&lt;button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="懶人包"><a href="#懶人包" class="headerlink" title="懶人包"></a>懶人包</h2><p>1.元件裡的最外層要長這樣子&lt;&gt;&lt;&#x2F;&gt;</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>加小括弧是避免有自動加;出現<span class="tag">&lt;/&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>2.單標籤自閉合 3.小駝峰命名</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>JSX 看似很囉唆但是裡面的每個規則都有相對的道理在，如果能去理解其實這些規則就相對應的記起來了。</p>
<p>預告一下，明日就是介紹如何在 JSX 寫 JavaScript 囉~</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官方網站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 21 React 的元件形式</title>
    <url>/2023/10/05/Day%2021%20React%E7%9A%84%E5%85%83%E4%BB%B6%E5%BD%A2%E5%BC%8F/</url>
    <content><![CDATA[<p>元件(component)是 React 主要關鍵組成之一，它是一個可以被反覆利用的 UI 元素，不過說穿了 React 的文件中一直提到的元件，其實就是 function 每一個元件都是由一個 function 當然裡面內層可以有很多個但是最外層就是只有一個，所以元件就是 function，如此一來元件可以重複使用就合理許多了吧!因為 function 也可以一直重複使用。</p>
<span id="more"></span>

<h2 id="如何定義元件-component"><a href="#如何定義元件-component" class="headerlink" title="如何定義元件(component)"></a>如何定義元件(component)</h2><p>這與其多說，不如來看範例吧!下列就是一個元件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Comp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一個元件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是跟 function 一模一樣，只是在 React 規定中元件開頭一定要<strong>大寫</strong>，然後要<strong>return</strong>出來是因為需要給其他地方使用，所以也需要匯出模組(<span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyOTU3MA==">ESM<i class="fa fa-external-link-alt"></i></span>)給其他檔案使用。其實還有一點，不過是 JSX 的語法問題，最上層需要有個這樣的&lt;&gt;&lt;&#x2F;&gt;根元素包住，換句話說 JSX 只能返回一個跟元素。</p>
<p>整理上述所說的 React 元件基本架構有那些呢?</p>
<h3 id="React-元件的基本架構"><a href="#React-元件的基本架構" class="headerlink" title="React 元件的基本架構"></a>React 元件的基本架構</h3><p>1.元件開頭命名一定要大寫 2.裡面需要 return 返回 3.最外層要有唯一一個標籤包住通常是&lt;&gt;&lt;&#x2F;&gt;，當然也可以是其它標籤 4.如果要給其它檔案使用一定要匯出</p>
<h4 id="補充-進入點"><a href="#補充-進入點" class="headerlink" title="補充:進入點"></a>補充:進入點</h4><p>說的直白點所謂的進入點，就是專案架構的最上層，但以剛入門 React 的人來說通常不會先理會這層，以 vite 而言所謂的進入點就是 main.js，初始設定長下面這樣。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom/client&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App.jsx&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)).<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>所以，通常在 React 匯出是一個必須的動作，因為以一個專案來說，再怎麼樣都會需要給進入點來使用，</p>
<h2 id="元件的引用"><a href="#元件的引用" class="headerlink" title="元件的引用"></a>元件的引用</h2><p>通常都是一個檔案一個元件，所以在引用元件的時候會做一個匯入的動作，而 React 在 render 元件的形式上也很特別，是以標籤的形式呈現，範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Comp</span> <span class="keyword">from</span> <span class="string">&quot;./Comp&quot;</span>; <span class="comment">//引用元件從其他檔案</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 可以重複使用 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="ps-在-vite-寫元件副檔名需要用-jsx"><a href="#ps-在-vite-寫元件副檔名需要用-jsx" class="headerlink" title="ps:在 vite 寫元件副檔名需要用 jsx"></a>ps:在 vite 寫元件副檔名需要用 jsx</h6><p>當然如果想偷懶一個檔案寫一堆元件也是可以，但是就不用做引入的動作了，範例如下:<br>只是不建議這麼而已</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* 可以重複利用 */&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Comp</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//React 的元件形式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Comp</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一個元件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>元件是 React 中基本的形式，整個架構幾乎都是由元件構成的，當然還有其中很重要的構成是 JSX 雖然一直提到，但還沒做詳細介紹，這部分明日會做比較詳細的介紹。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官方網站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 20 React 環境建置-Vite</title>
    <url>/2023/10/04/Day%2020%20React%20%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE-Vite/</url>
    <content><![CDATA[<p>在接下來的範例中，比較沒辦法像之前的範例一樣直接丟到瀏覽器，檢查的開發者工具直接執行，需要建置基本的環境，我有想過幾種方式進行建置，甚至是在 codesandbox 直接線上進行，但比起線上的環境還是比較喜歡在本地端用 VS Code 進行開發，在追求方便簡單的前提下，選擇了 Vite 進行部屬。</p>
<span id="more"></span>

<h2 id="環境建置前的準備-NPM-Node-Package-Manager"><a href="#環境建置前的準備-NPM-Node-Package-Manager" class="headerlink" title="環境建置前的準備-NPM(Node Package Manager)"></a>環境建置前的準備-NPM(Node Package Manager)</h2><p>在使用 Vite 部屬前需要安裝 node 套件管理器(npm)來方便進行 Vite 部屬，而 NPM 是 Node 的安裝管理套件，簡單來說就是綁定 Node，所以安裝 node 就可以使用囉!</p>
<h3 id="Node-下載與安裝"><a href="#Node-下載與安裝" class="headerlink" title="Node 下載與安裝"></a>Node 下載與安裝</h3><p>Node.js:<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2Vu">https://nodejs.org/en<i class="fa fa-external-link-alt"></i></span><br>推薦 LTS 版本，因為是長期維護的版本使用起來也會比最新版本還穩定，而安裝方式跟其他應用程式一樣簡單，只要一直按下一步就可以安裝完成了。</p>
<h2 id="使用-Vite-進行環境建置"><a href="#使用-Vite-進行環境建置" class="headerlink" title="使用 Vite 進行環境建置"></a>使用 Vite 進行環境建置</h2><p><strong>1.找到 VS Code 的終端機</strong><br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day20-1_txslex.png"></p>
<p><strong>2.輸入指令</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm create vite@latest <span class="comment">//創建最新版本的專案</span></span><br></pre></td></tr></table></figure>

<p><strong>3.然後 vite 會詢問一系列的設定</strong></p>
<p>(1)確定是否要執行程序&#x3D;&gt;按 y<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day20-2_iadmfb.png"></p>
<p>(2)取專案名子&#x3D;&gt;可以隨便取或是用預設<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day20-3_jh78me.png"></p>
<p>(3)選擇哪一個框架&#x3D;&gt;選擇 React<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day20-4_kqvokg.png"></p>
<p>(4)選擇使用哪一個語言&#x3D;&gt;選擇 JavaScript<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day20-5_l0n73d.png"></p>
<p>(5)基本上就大致完成了，接下來是進行測試有無建置成功的部份，也很單純就照著 vite 提供的指令一行一行打就好了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd vite-project <span class="comment">//切換到專案目錄的資料夾</span></span><br><span class="line">npm install <span class="comment">//安裝模組</span></span><br><span class="line">npm run dev <span class="comment">//開啟測試環境</span></span><br></pre></td></tr></table></figure>

<p><strong>4.如此一來就完成了，理論上應該是可以在下列網址(<span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo1MTczLyklRTQlQjglQUQlRTclOUMlOEIlRTUlODglQjAlRTQlQjglOEIlRTklOUQlQTIlRTclOUElODQlRTclOTUlQUIlRTklOUQlQTI=">http://localhost:5173/)中看到下面的畫面<i class="fa fa-external-link-alt"></i></span></strong><br>(1)終端機回饋的網址<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day20-6_j7gjkt.png"><br>(2)出現的測試畫面<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day20-7_sihsxw.png"></p>
<p><strong>5.操作的檔案位置(src&#x3D;&gt;App.js)</strong><br>位在 src 資料夾的 App.js，未來的操作範例都可以在這個檔案進行。<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day20-8_s5uoza.png"></p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>雖然步驟還是有點多或是有點麻煩，但如果要在本地端開發，這已經是相對簡單快速的方法了，明天就會正式進入 React 囉~</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 19 React 介紹</title>
    <url>/2023/10/03/Day%2019%20React%20%E4%BB%8B%E7%B4%B9/</url>
    <content><![CDATA[<h2 id="歷史發展"><a href="#歷史發展" class="headerlink" title="歷史發展"></a>歷史發展</h2><p>React 正式出現在眾人眼中是在 JSConf 上，來自原 Facebook 團隊 Jordan Walke 把一直以來在內部使用的 React 開源了，不過在當時的回響並不是很好，甚至受到了一些批評。</p>
<p>在開源團隊努力的推廣下，某些人開始慢慢發現 React 的好，隨之開源社群也慢慢建立了起來，到了 2016 年左右變成了一種主流框架，在那時 React 在前端圈子的地位被確立。</p>
<p>2019 年 Hook 被正式引入到 React 當中，同時也降低了學習成本，到現今 Hook 應該也是蠻多人會選擇開發的方式，也讓 React 使用人數持續成長，現在 React 應該還是使用人數最多的框架之一。</p>
<span id="more"></span>

<h2 id="什麼是-React"><a href="#什麼是-React" class="headerlink" title="什麼是 React?"></a>什麼是 React?</h2><p>在主流的認知裡，大家常常提到的三大框架 Angular、React、Vue，式的沒錯大家是把 React 當作框架來看，但弔詭的是 React 的官方網站，卻開宗明義地強調”The <strong>library</strong> for web and native user interfaces”，React 是一個函式庫，就跟經典的 jQuery 一樣是一個函式庫，以此來強調 React 的輕量化及靈活性。</p>
<h2 id="React-特色"><a href="#React-特色" class="headerlink" title="React 特色"></a>React 特色</h2><p>1.元件化的特性，讓相似的區塊做成元件能重複使用</p>
<p>2.使用 JSX 語法，讓 HTML 標籤上可以使用 JavaScript 進行操作，大幅降低程式的複雜度，提升寫程式的效率</p>
<p>3.如果單獨元件有更新資料，可以只對單獨的元件進行重新渲染，不用刷新整個頁面</p>
<p>4.專注在畫面的呈現處理</p>
<h2 id="為什麼選擇-React"><a href="#為什麼選擇-React" class="headerlink" title="為什麼選擇 React"></a>為什麼選擇 React</h2><p>綜合上述特色，加上龐大的使用者社群，在學習上的資源也相對多，雖然入門的門檻高了點，但跨過了，就可以感受到 React 的方便性了。</p>
<p>##參考資料<br><span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj04cERxSlZkTmE0NCZ0PTRz">Origin Story: How A Small Team of Developers Created React.js at Facebook<i class="fa fa-external-link-alt"></i></span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官方網站<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 18 正式進入 React 前的 Javascript 小總結</title>
    <url>/2023/10/02/Day%2018%20%E6%AD%A3%E5%BC%8F%E9%80%B2%E5%85%A5React%E5%89%8D%E7%9A%84Javascript%E5%B0%8F%E7%B8%BD%E7%B5%90/</url>
    <content><![CDATA[<p>不知不覺鐵人賽已經寫超過一半了，用 JavaScript 水內容也水的差不多了 XD，但是我真心認為前面的內容都是我恨不得在學 React 之前能夠所學好的內容，至少在操做 React 的時候不會因為 JavaScript 而卡東卡西的，而且 React 本身已經夠難懂了。</p>
<p>在今天這個算是中場休息的時間，來稍微整理前面的內容，和提出接下來要進行的架構。依然是遵從本系列的定位，盡可能地減少在學習 React 之前的落差，所以並不會提到太多太難的內容，因為比較難的內容我相信版上已經有很多大神寫文章了，我能做到的是盡量地做銜接。</p>
<span id="more"></span>

<h2 id="JavaScript-複習篇"><a href="#JavaScript-複習篇" class="headerlink" title="JavaScript 複習篇"></a>JavaScript 複習篇</h2><p><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMxNDQzMg==">Day1 參賽動機以及題目選擇和預計大綱<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMxODY5Mg==">Day2 My VS Code Tour<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMxOTA1OQ==">Day3 查詢陣列的方法-forEach &amp; map<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyMDk4MA==">Day4 操作陣列的方法 Part.1-push &amp; pop<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyMjMyNQ==">Day5 操作陣列的方法 Part.2-shift &amp; unshift<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyMzI0MA==">Day6 其他的陣列方法 slice &amp; splice<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyMzk4Nw==">Day7 搜尋陣列的方法-find,findIndex &amp; filter<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyNDgyOA==">Day8 字串陣列互相變化的方法 split &amp; join<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyNTYwNA==">Day9 函式與箭頭函式<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyNjYyNA==">Day10 物件(Object)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyNzgyNg==">Day11 解構賦值(Destructuring assignment)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyODk5MA==">Day12 其餘運算子 &amp; 展開運算子(Spread Operator &amp; Rest Operator)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMyOTU3MA==">Day13 JavaScript 模組(Modules)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMzMDI0OA==">Day14 同步&amp;非同步(Synchronous &amp; Asynchronous)<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMzMDY4Mw==">Day15 處理同步(Synchronous)和非同步(Asynchronous)的方法 Part.1<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMzMTIyMQ==">Day16 處理同步(Synchronous)和非同步(Asynchronous)的方法 Part.2-Promise<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly9pdGhlbHAuaXRob21lLmNvbS50dy9hcnRpY2xlcy8xMDMzMTkzMQ==">Day17 處理同步(Synchronous)和非同步(Asynchronous)的方法 Part.3-Async Await<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="React-預計大綱"><a href="#React-預計大綱" class="headerlink" title="React 預計大綱"></a>React 預計大綱</h2><p>Day19 React 介紹<br>Day20 React 環境建置<br>Day21 React 元件的形式<br>Day22 React 的語法-JSX<br>Day23 React 中的 JavaScript<br>Day24 React 的橋樑-Prpos<br>Day25 React 的渲染-JSX 與三元運算子的關係<br>Day26 React 的多重渲染-列表與 Key<br>Day27 React 的純函數元件<br>Day28 React 的 Hello World-Hook-useState<br>Day29 React 的玄學<br>Day30 總結</p>
<h2 id="中場休息之小小心得"><a href="#中場休息之小小心得" class="headerlink" title="中場休息之小小心得"></a>中場休息之小小心得</h2><p>其實我很驚訝我能走到這裡，身為一個前端小菜雞，縱使知道自己寫的沒有很理想，但還是不知羞恥的寫下去，希望能透過這次的鐵人賽，能對這段時間的學習有個交代。</p>
<p>如果你是跟我一樣剛接觸 React 的新手或是讀到這裡的讀者可能對 React 產生一點興趣的人，期待我們能在各自的天空繼續走下去。</p>
<p>附帶一提，給想入門 React 的人一句”歡迎來到 React 地獄~”</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day17 處理同步(Synchronous)和非同步(Asynchronous)的方法 Part.3-Async Await</title>
    <url>/2023/10/01/Day%2017%20%E8%99%95%E7%90%86%E5%90%8C%E6%AD%A5(Synchronous)%E5%92%8C%E9%9D%9E%E5%90%8C%E6%AD%A5(Asynchronous)%E7%9A%84%E6%96%B9%E6%B3%95Part.3-Async%20Await/</url>
    <content><![CDATA[<h2 id="Async-Await"><a href="#Async-Await" class="headerlink" title="Async Await"></a>Async Await</h2><p>是 promise 的語法糖，這是一組雙生一對在正常的情況下無法分離的東西，那它是如何進行簡化的呢?<br>引用 MDN 解釋</p>
<span id="more"></span>

<blockquote>
<p>當 async 函式被呼叫時，它會回傳一個 Promise。如果該 async 函式回傳了一個值，Promise 的狀態將為一個帶有該回傳值的 resolved。如果 async 函式拋出例外或某個值，Promise 的狀態將為一個帶有被拋出值的 rejected。</p>
<p>async 函式內部可以使用 await 表達式，它會暫停此 async 函式的執行，並且等待傳遞至表達式的 Promise 的解析，解析完之後會回傳解析值，並繼續此 async 函式的執行。</p>
</blockquote>
<p>沒錯還是一如既往地讓人很難以理解，那就直接來看範例吧!會比較清楚一點，讓我們先回顧昨日的範例。</p>
<h2 id="範例"><a href="#範例" class="headerlink" title="範例"></a>範例</h2><h3 id="Promise-昨日範例"><a href="#Promise-昨日範例" class="headerlink" title="Promise-昨日範例"></a>Promise-昨日範例</h3><p>依序 console.log() 出 1,2,3,4，但是 2,3 有 setTimeout，所以需要利用 new promise 進行處理然後回傳處理成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Async-Await-語法"><a href="#Async-Await-語法" class="headerlink" title="Async Await 語法"></a>Async Await 語法</h3><p>上述是單純用 promise 寫的那加入 async await 的改寫就變成下方的型式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比較一下之後我們可以發現幾個特性: 1.把需要排列執行順序的非同步函式用 async function 全部裝在一起 2.把需要被處理或是等待執行的非同步掛上 await，這時 await 的作用就是讓程式執行完成後才會繼續 3.注意 awiat 裡面需要一個 promise 作為回傳</p>
<p>所以整理一下 Async Await 基本語法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> 函式名稱() &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    放入需要被處理的非同步<span class="number">1</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    放入需要被處理的非同步<span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此一來簡單的 Async Await 語法架構就完成囉!</p>
<h3 id="Async-Await-錯誤檢查"><a href="#Async-Await-錯誤檢查" class="headerlink" title="Async Await 錯誤檢查"></a>Async Await 錯誤檢查</h3><p>但是，眼尖的朋友應該會發現少了什麼東西，那就是 resolve 或是 reject 的結果要麼處理呢?有一種方法就是直接還給它，因為 await 的語法會 return 一個 promise 物件，所以其實 ++promise 的.then()或是.catch()還是能用的++。</p>
<p>又或是出動我們的老朋友<strong>try catch</strong>協助我們確認程式有沒有被正確執行也是一種選擇。</p>
<p>下面的範例是採用第一種用.then 的方式去檢查</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">      <span class="title function_">resolve</span>(<span class="string">&quot;success2&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>其實說穿了 Async Await 就是一個語法糖，所以只要了解了 promise 然後記住 Async Await 的架構，對於非同步的處理方法來說學習上並不會有太多的阻礙，而且反而能使用更簡單易讀的方法來處理非同步問題。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 16 處理同步(Synchronous)和非同步(Asynchronous)的方法 Part.2-Promise</title>
    <url>/2023/09/30/Day%2016%20%E8%99%95%E7%90%86%E5%90%8C%E6%AD%A5(Synchronous)%E5%92%8C%E9%9D%9E%E5%90%8C%E6%AD%A5(Asynchronous)%E7%9A%84%E6%96%B9%E6%B3%95Part.2-Promise/</url>
    <content><![CDATA[<p>今天要來介紹的是現在比較常用處理非同步的方法分別是 promise，這裡會先大幅度的簡化 promise 的用法，來先理解整個 promise 的運作概念。</p>
<span id="more"></span>

<h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><p><strong>1.創建 promise:</strong> 為什麼需要創建 promise 因為它是一個建構函式，所以需要使用關鍵字 new 去創建 promise，裡面帶兩個參數分別為 resolve, reject。<br>resolve:代表執行成功地回傳值<br>reject:代表執行失敗的回傳值</p>
<p><strong>2.then&amp;catch:</strong> .then()代表著 promise 執行成功後所需要執行的區塊，而且可以接 reslove 的回傳值;.catch()代表 promise 執行失敗後所需要執行的區塊，而且可以接 reject 的回傳值。</p>
<p><strong>3.then 串接:</strong> .then 是可以串接的，甚至是可以在 then 裡面再多 new 一個 Promise 物件，來處理多個非同步的問題</p>
<p>綜合上述提到的三點，範例如下:<br>我需要依序 console.log() 出 1,2,3,4，但是 2,3 有 setTimeout，所以需要利用 new promise 進行處理然後回傳處理成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;success1&quot;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>今天就先簡單介紹現在處理非同步的方法，但是強調 promise 還有很多種用法，但如果以一個初學的角度來看還是先熟悉基礎用法，會在使用上比較不容易造成混淆</p>
<p>事實上，ES6 之後還有一個語法 async await，它是 promise 的語法糖，在寫法上比 promise 更簡潔易懂，這部份就留做明天來介紹吧~</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 15 處理同步(Synchronous)和非同步(Asynchronous)的方法 Part.1</title>
    <url>/2023/09/29/Day%2015%20%E8%99%95%E7%90%86%E5%90%8C%E6%AD%A5(Synchronous)%E5%92%8C%E9%9D%9E%E5%90%8C%E6%AD%A5(Asynchronous)%E7%9A%84%E6%96%B9%E6%B3%95Part.1/</url>
    <content><![CDATA[<h3 id="非同步所造成的問題"><a href="#非同步所造成的問題" class="headerlink" title="非同步所造成的問題"></a>非同步所造成的問題</h3><p>昨天介紹過了什麼是同步和非同步，今天要來介紹的是處理的方法，也就是說要來處理非同步所產的不確定性帶來的問題，比較具體的例子如下:</p>
<p>這是一個經典的例子，我期望的是 console.log()的順序為 1,2,3，但其實執行的結果為 1,3,2。<br>這是因為 setTimeout 產生了非同步行為，在 JavaScript 當中程式並不會等 setTimeout 執行而是會先把它丟到旁邊往下走等到時間到才會回來執行 setTimeout。</p>
<p>但是這樣就達不到我的需求，於是就產生了相對應的處理方法</p>
<span id="more"></span>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>); <span class="comment">//setTimeout的意思是等多久才會執行，參數為1個回調函式+毫秒數這裡為1000</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h3 id="處理非同步的方法"><a href="#處理非同步的方法" class="headerlink" title="處理非同步的方法"></a>處理非同步的方法</h3><ol>
<li>回調函數（Callback Functions）： 回調函數是處理非同步非常古老的一種方法，有名的 callback Hell 就是因此誕生了，現在這個方法很少被使用，但還是介紹一下，其原理就是利用函式需要被呼叫的特性來達成想要程式執行的先後順序。利用上述的例子說明:</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">call1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">call2</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="title function_">callback</span>();</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">call3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callNumber</span>(<span class="params">call1</span>) &#123;</span><br><span class="line">  <span class="title function_">call1</span>(<span class="title function_">call2</span>(call3));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">callNumber</span>(call1);</span><br></pre></td></tr></table></figure>

<p>就會長出上面這種奇形怪狀不易閱讀的程式碼，所以 ES6 就發明出更簡潔的 Promises 語法還有 async await 提拱使用，這些就留到明日在做介紹。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day14 同步&amp;非同步(Synchronous &amp; Asynchronous)</title>
    <url>/2023/09/28/Day%2014%20%E5%90%8C%E6%AD%A5&amp;%E9%9D%9E%E5%90%8C%E6%AD%A5(Synchronous%20&amp;%20Asynchronous)/</url>
    <content><![CDATA[<p>就中文來看這兩種的意思其實相當容易被搞混的，我自己常常在閱讀文章時也很常莫名的被這兩個名詞搞昏頭。所以我會直接用例子來幫助記憶接說明如下:</p>
<span id="more"></span>

<ol>
<li><p>同步(Synchronous):就是 A 處理完再處理再處理 C</p>
<p>A -&gt; B -&gt; C-&gt;</p>
</li>
<li><p>非同步(Asynchronous):就是可以同時處理 ABC</p>
<p>–&gt;A<br>|<br>–&gt;B<br>|<br>–&gt;C</p>
</li>
</ol>
<p>那話又說回來 JavaScript 是屬哪一種呢?</p>
<p>引用 MDN 的定義</p>
<blockquote>
<p>Javascript 基本上是一個同步性的、阻塞的，且是跑在單一執行緒的程式語言，也就是在同一時間只能執行一個操作。但是瀏覽器所定義的函式和 API 允許我們註冊一個不該被同步執行的函式，且這個函式應該在某些事件發生時需要非同步的被呼叫（到達指定的時間、使用者透過滑鼠互動，或者取得透過從網路所取到的資料）。這代表你可以讓你的程式碼在同時間做一些事情而不需暫停或阻塞你的主執行緒。</p>
</blockquote>
<p>簡單來說，MDN 很明確的定義 javascript 是一個同步性的語言，但可以處理或是說可以執行非同步的方法。下面的例子可以說明:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;registering click handler&quot;</span>);</span><br><span class="line"></span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;get click&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;all done&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>PS:上述是簡化後的例子，真的需要執行的話如下網址:<br><span class="exturl" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL0hzaWVubHUvcGVuL1BvWGV2cko=">https://codepen.io/Hsienlu/pen/PoXevrJ<i class="fa fa-external-link-alt"></i></span></p>
<p>可以發現實際在執行的時候，”all done”並不會等到”get click”被觸發時才會出現，而是會直接執行，所以才會說雖然 JavaScript 是同步性的語言，但可以處理需要非同步處理的事情。</p>
<p>但是，非同步的事情常常會具有不確定性存在(不知道哪個會先發生哪個會後發生)，於是就有了一些處理同步和非同步的方法，這些方法明天會繼續介紹。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p>1.<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0FzeW5jaHJvbm91cy9JbnRyb2R1Y2luZw==">非同步的 JavaScript 介紹<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day13 JavaScript 模組(Modules)</title>
    <url>/2023/09/27/Day%2013%20JavaScript%20%E6%A8%A1%E7%B5%84(Modules)/</url>
    <content><![CDATA[<p>模組系統的概念大致上分兩種寫法，CommonJS 和 ESM 其引入方式的差異分別是 require 和 import，今天會著重在 ESM 的寫法。</p>
<p>模組的概念其實在 React 框架已經不知不覺地被頻繁的使用了，像是最常見的 hook–useState 就是在引入模組的時候才做使用的，又或是元件的寫法也是由模組系統做延伸。</p>
<p>模組基本上可以分為兩種匯出方式命名匯出(Named Exports)和預設匯出(Default Exports)，其對應的匯入方式也有所差別</p>
<span id="more"></span>

<h3 id="命名匯出-Named-Exports"><a href="#命名匯出-Named-Exports" class="headerlink" title="命名匯出(Named Exports)"></a>命名匯出(Named Exports)</h3><p>命名匯出使用關鍵詞 &#x3D;&#x3D;export&#x3D;&#x3D;+&#x3D;&#x3D;要輸出東西的名稱&#x3D;&#x3D;，好處是在於同一個檔案能使用很多個匯出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其對應的匯入方式如下，import 模組，然後從哪裡 from</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;add, subtract&#125; <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 輸出: 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">subtract</span>(<span class="number">10</span>, <span class="number">4</span>)); <span class="comment">// 輸出: 6</span></span><br></pre></td></tr></table></figure>

<h3 id="預設匯出-Default-Exports"><a href="#預設匯出-Default-Exports" class="headerlink" title="預設匯出(Default Exports)"></a>預設匯出(Default Exports)</h3><p>1.預設匯出使用關鍵詞 &#x3D;&#x3D;export default&#x3D;&#x3D;，特別注意同一個檔案只能有一個預設匯出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其對應的匯入方式如下，與上述雷同差別在於針對單一輸出的模組所以可以不用大括弧{}</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">&quot;./math&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 輸出: 8</span></span><br></pre></td></tr></table></figure>

<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>以下簡單整理一個表格，我自己會認為不太需要花時間去記憶，因為用久自然就熟了，而且現在套件的幫助下其實也比較不太會在這方面出差錯。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>命名匯出出 (Named Exports)</th>
<th>預設匯出 (Default Export)</th>
</tr>
</thead>
<tbody><tr>
<td>匯出方式</td>
<td>可以匯出多個具名功能</td>
<td>只能匯出一個默認功能</td>
</tr>
<tr>
<td>匯入的語法</td>
<td>使用 <code>&#123;&#125;</code> 語法進行匯入</td>
<td>直接使用模組名稱進行匯入</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day12 其餘運算子 &amp; 展開運算子(Spread Operator &amp; Rest Operator)</title>
    <url>/2023/09/26/Day%2012%20%E5%85%B6%E9%A4%98%E9%81%8B%E7%AE%97%E5%AD%90%20&amp;%20%E5%B1%95%E9%96%8B%E9%81%8B%E7%AE%97%E5%AD%90(Spread%20Operator%20&amp;%20Rest%20Operator)/</url>
    <content><![CDATA[<p>接著就是傳說中的…了，正式名稱為其餘運算子和展開運算子，這個點點點同時具有兩種功能，也是在 React 中被廣泛使用的，接下來依序介紹</p>
<span id="more"></span>

<h3 id="1-其餘運算子"><a href="#1-其餘運算子" class="headerlink" title="1.其餘運算子"></a><strong>1.其餘運算子</strong></h3><p>其實在昨天的文章中以已經有先使用這個與法了，這個功能的作用顧名思義就是可以接剩下來的值<br>引用 MDN 的說法:</p>
<blockquote>
<p>“這個語法可以讓我們表示&#x3D;&#x3D;不確定數量的參數&#x3D;&#x3D;，並將其視為一個&#x3D;&#x3D;陣列&#x3D;&#x3D;。”</p>
</blockquote>
<p>在實際用途會在兩個地方，一個是在解構賦值，其實昨天的文章已經有偷偷用到了；另一個是在傳入不確定量參數的時候。</p>
<p><strong>(1) 解構賦值</strong><br>…rest 的作用就是用來接解構賦值命名完變數剩下來的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> a, b, rest;</span><br><span class="line">[a, b, ...rest] = array;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//輸出:1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//輸出:2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest); <span class="comment">//輸出:3,4,5</span></span><br></pre></td></tr></table></figure>

<p><strong>(2) 傳入不確定量的參數</strong><br>這裡直接舉一個情境，我想要傳入一列數字但&#x3D;&#x3D;不確定&#x3D;&#x3D;有多少數字，並設計一個函示找出最小值，範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMin</span>(<span class="params">...<span class="built_in">Array</span></span>) &#123;</span><br><span class="line">  <span class="comment">//^^^^^^^^傳入不確定參數的量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>);</span><br><span class="line">  <span class="keyword">let</span> minValue = <span class="title class_">Math</span>.<span class="title function_">min</span>(...<span class="title class_">Array</span>);</span><br><span class="line">  <span class="comment">//^^^那這個點點點又是什麼呢?</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(minValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">findMin</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>相信大家都有注意到 Mata.min 的…又是什麼呢?這其實跟昨天文章提到的解構有關。</p>
<p><strong>(3) 解構其餘參數</strong><br>當初在學這個時候，還沒有想到這個點點點有這樣神奇的功能，直接引用 MDN 的定義</p>
<blockquote>
<p>其餘參數可以被解構，換句話說，可以把這個<strong>陣列</strong>解開，並將各個元素取出成為個別的變數。請參考解構賦值。</p>
<p>其實這個功能我認為跟下面準備要提的展開運算子其實蠻相似的，只是 MDN 有另外再把它定義出來。<br>重點就是，其餘參數追根究柢就是一個&#x3D;&#x3D;陣列&#x3D;&#x3D;需要把陣列展開來，所以其實如果上述範例改成下面這個例子是會跑出 NaN 的，因為 Math.min()沒辦發接受傳入純陣列</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">findMin</span>(<span class="params">...<span class="built_in">Array</span></span>) &#123;</span><br><span class="line">  <span class="comment">//^^^^^^^^傳入不確定參數的量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>);</span><br><span class="line">  <span class="keyword">let</span> minValue = <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title class_">Array</span>); <span class="comment">//輸出:NaN</span></span><br><span class="line">  <span class="comment">//^^^那這個點點點又是什麼呢?</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(minValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">findMin</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<h3 id="2-展開運算子"><a href="#2-展開運算子" class="headerlink" title="2.展開運算子"></a><strong>2.展開運算子</strong></h3><p>MDN 定義</p>
<blockquote>
<p>展開運算子, 可以在函數調用&#x2F;陣列構造時，將陣列表達式或者 string 在語法層面展開<br>其實講的簡單一點就是把一個陣列的中刮弧拿掉的意思，後還有一個特殊功能就是可以對類陣列進行展開。</p>
</blockquote>
<p><strong>(1)陣列展開</strong><br>有名的淺拷貝就是一個經典的例子，如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> newArray = [...array];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br><span class="line"><span class="comment">//上述兩個會是名稱不一樣，但是內容一模一樣的陣列。</span></span><br></pre></td></tr></table></figure>

<p>其實在使用上，我會認為不太需要去區分的太仔細，或是刻意去記憶，因為其實本身在使用的情境上去做區分，所以多去使用它自然而然的就可以對這兩類與法做出一些區別。</p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p>1.<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycw==">MDN 其餘運算子<i class="fa fa-external-link-alt"></i></span></p>
<p>2.<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL1NwcmVhZF9zeW50YXg=">MDN 展開運算子<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day11 解構賦值(Destructuring assignment)</title>
    <url>/2023/09/25/Day%2011%20%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC(Destructuring%20assignment)/</url>
    <content><![CDATA[<p>解構賦值是 ES6 新增的語法，根據 MDN 的說法<strong>解構賦值 (Destructuring assignment) 語法是一種 JavaScript 運算式，可以把陣列或物件中的資料解開擷取成為獨立變數。</strong><br>簡單來說就是解構賦值是一種專門針對陣列或是物件的運算式，作用是把裡面的資料存成獨立變數。</p>
<span id="more"></span>

<p><strong>1.陣列的解構賦值</strong><br>基本寫法範例如下，&#x3D;就像是一面鏡子&#x3D;&#x3D;依序&#x3D;&#x3D;對照著兩邊，下面範例示範了 2 個點<br>(1)用 a 和 b 對照著 array 中的 1 和 2<br>(2)用…rest 對照著剩下的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> a, b, rest;</span><br><span class="line">[a, b, ...rest] = array;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//輸出:1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//輸出:2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rest); <span class="comment">//輸出:3,4,5</span></span><br></pre></td></tr></table></figure>

<p><strong>2.物件的解構賦值</strong></p>
<p>在 React 中物件的解構賦值很常用在 props 的參數傳遞，最單純直接的用法就是{屬性名稱}，有點像陣列的物件取值那樣，也可以賦予新的變數名稱，範例如下<br><strong>(1) 取值</strong>:把屬性名稱解構成新的變數並帶入原本的屬性值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name, age&#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br></pre></td></tr></table></figure>

<p><strong>(2) 賦予變數名稱</strong>:利用鏡射的方式讓物件中的屬性值有了新的變數名稱</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="variable constant_">AAA</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="variable constant_">BBB</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="variable constant_">CCC</span>,</span><br><span class="line">&#125; = &#123;<span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">isStudent</span>: <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">AAA</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">BBB</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">CCC</span>);</span><br></pre></td></tr></table></figure>

<p>**(3) 搭配函式傳入引數，再傳入引數為物件時(常見在 React props 中)，可以利用解構賦值，讓語法更為簡潔</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">helloFunction</span> = (<span class="params">&#123;name&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">helloFunction</span>(person);</span><br></pre></td></tr></table></figure>

<p>當使用解構賦值（Destructuring Assignment）時，儘管它不是絕對必要的，但確實可以使您的程式碼更加簡潔、易讀，尤其在 React 中傳遞 props 時，這種做法很常見，而且也被廣為使用。</p>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0Rlc3RydWN0dXJpbmdfYXNzaWdubWVudA==">MDN 解構賦值<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 10 物件(Object)</title>
    <url>/2023/09/24/Day%2010%20%E7%89%A9%E4%BB%B6(Object)/</url>
    <content><![CDATA[<p>在前端這個花花綠綠的世界，物件是一個傳遞資料很重要的形式，大家熟悉的 json 檔，裡面大部分都是由各種陣列和物件所構成的，所以身為一個前端框架，怎麼樣處理物件也是需備知道的。</p>
<span id="more"></span>

<h3 id="物件的特性"><a href="#物件的特性" class="headerlink" title="物件的特性"></a>物件的特性</h3><p>1.被大括弧包起來 2.裡面是由屬性組成而屬性是由屬性名稱和屬性值組成，如果有學過 PHP 的關聯式陣列的話，感覺有點像是鍵和鍵值。 3.屬性值可以是數字、字串、陣列、甚至其他物件或函數這裡會稱其為方法，<br>實際物件的樣子如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="讀取物件的方法"><a href="#讀取物件的方法" class="headerlink" title="讀取物件的方法"></a>讀取物件的方法</h3><p>陣列取值的方法有兩種:</p>
<p><strong>1.點記法(Dot notation)</strong><br>顧名思義就是用.來取值，直接看範例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">//輸出:John</span></span><br></pre></td></tr></table></figure>

<p><strong>2.物件陣列取值(Bracket notation)</strong><br>在 MDN 又稱括弧記法，只是我覺得陣列取值這個名稱比較生動，其最大的優點是可以利用變數或是運算方法取值，範例如下:<br>(1).普通的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[<span class="string">&quot;name&quot;</span>]); <span class="comment">//輸出:John</span></span><br></pre></td></tr></table></figure>

<p>(2).變數</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> props = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[props]); <span class="comment">//輸出:John</span></span><br></pre></td></tr></table></figure>

<p>(3).運算方法:雖然這個範例有點硬要，但我希望還是能盡量簡化範例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> props1 = <span class="string">&quot;na&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> props2 = <span class="string">&quot;me&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isStudent</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person[props1 + props2]); <span class="comment">//輸出:John</span></span><br></pre></td></tr></table></figure>

<h3 id="建立物件的方法"><a href="#建立物件的方法" class="headerlink" title="建立物件的方法"></a>建立物件的方法</h3><p>建立物件的方法有許多種，比較常見的就是直接宣告又稱 Object Literal，還有 new 搭配建構函式，當然 ES6 也有新增的語法糖類別(class)跟 constructor 可以運用</p>
<p><strong>1. 直接宣告(Object Literal)</strong><br>顧名思義就是直接宣告一個物件，範例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立物件</span></span><br><span class="line"><span class="keyword">let</span> people = &#123;&#125;;</span><br><span class="line"><span class="comment">//新增內容至物件</span></span><br><span class="line">people.<span class="property">name</span> = <span class="string">&quot;amy&quot;</span>;</span><br><span class="line">people.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line"><span class="comment">//輸出結果</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people);</span><br></pre></td></tr></table></figure>

<p><strong>2. new 搭配建構函式</strong><br>先建立一個增加物件的函式，然後呼叫函示建立物件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加物件的函式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">people</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函示建立物件</span></span><br><span class="line"><span class="keyword">let</span> newPerson = <span class="keyword">new</span> <span class="title function_">people</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPerson);</span><br></pre></td></tr></table></figure>

<p><strong>3. class 語法糖</strong><br>class 加上 constructor 也可以建立一個物件，範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加物件的函式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函示建立物件</span></span><br><span class="line"><span class="keyword">let</span> newPerson = <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newPerson);</span><br></pre></td></tr></table></figure>

<p>上述是基本的物件的一些特性以及基本的使用方法，至少要先知道是怎麼來的以及怎麼使用，會對之後在 React 上進行資料處理的時候順暢一點。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 9 函式與箭頭函式</title>
    <url>/2023/09/23/Day%209%20%E5%87%BD%E5%BC%8F%E8%88%87%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="函式-function"><a href="#函式-function" class="headerlink" title="函式 function"></a>函式 function</h2><p>在 React 中，會經常使用函數來建立和管理 React 中的各項元件，而 React 架構的網頁實際上又是由個元件組成的，所以在進入 React 之前了解一些 function 的觀念有其必要性存在。</p>
<span id="more"></span>

<h3 id="function-的宣告方法"><a href="#function-的宣告方法" class="headerlink" title="function 的宣告方法"></a>function 的宣告方法</h3><p>大致上比較常用的有下列三種</p>
<p>第一種:最為常見使用有名稱的函式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure>

<p>第二種:用變數宣告匿名函式,可以防止 function hoisting 的問題</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure>

<p>第三種:用物件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = &#123;</span><br><span class="line">  <span class="attr">callName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">name.<span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="function-與-return-的特性"><a href="#function-與-return-的特性" class="headerlink" title="function 與 return 的特性"></a>function 與 return 的特性</h3><ol>
<li>函式必定有回傳值，如果沒有回傳值，值就是 undefined</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">callName</span>();</span><br><span class="line"><span class="comment">//會出現Tom與undefined</span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897455/ith2023-article-pic/day9-1_cn1xwf.png"></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">callName</span>();</span><br><span class="line"><span class="comment">//不會出現undefined</span></span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897455/ith2023-article-pic/day9-2_akmg38.png"></p>
<ol start="2">
<li>return 具有中斷函式的特性</li>
<li>return 後方可以加入表達式</li>
</ol>
<h3 id="函式預設參數值-function-Default-parameters"><a href="#函式預設參數值-function-Default-parameters" class="headerlink" title="函式預設參數值 function Default parameters"></a>函式預設參數值 function Default parameters</h3><p>根據 MDN 的說法”函式預設參數 允許沒有值傳入或是傳入值為 undefined 的情況下，參數能以指定的預設值初始化。”，不過簡單來說就是給一個函式預設的值，範例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params">name = <span class="string">&quot;Tom&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">callName</span>();</span><br></pre></td></tr></table></figure>

<h3 id="IIFE-立即執行函數"><a href="#IIFE-立即執行函數" class="headerlink" title="IIFE 立即執行函數"></a>IIFE 立即執行函數</h3><p>顧名思義就是立即執行函數，雖然有點像廢話，不過就是讓函式在定義的時候馬上執行一次。</p>
<p>引用 MDN 的說明</p>
<blockquote>
<p>他又稱為 Self-Executing Anonymous Function，是一種常見的設計模式，包含兩個主要部分：<br>第一個部分是使用 Grouping Operator () 包起來的 anonymous function。這樣的寫法可以避免裡面的變數污染到 global scope。<br>第二個部分是馬上執行 function 的 expression ()，JavaScript 引擎看到它就會立刻轉譯該 function。</p>
</blockquote>
<p>其寫法有兩種，<br>第一種:第二個小括弧在外面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params">name = <span class="string">&quot;Tom&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>第二種:第二個小括弧在裡面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> <span class="title function_">callName</span>(<span class="params">name = <span class="string">&quot;Tom&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>無論是哪一種就不用還需要額外呼叫函示囉<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897455/ith2023-article-pic/day9-3_gl1jrm.png"></p>
<h2 id="箭頭函式-arrow-function"><a href="#箭頭函式-arrow-function" class="headerlink" title="箭頭函式 arrow function"></a>箭頭函式 arrow function</h2><p>是一種函式的簡寫法，當然與原本 function 的形式還是有些許的不同</p>
<h3 id="箭頭函式的寫法"><a href="#箭頭函式的寫法" class="headerlink" title="箭頭函式的寫法"></a>箭頭函式的寫法</h3><p>以上面的例子而言寫成箭頭函式的形式如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">callName</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="箭頭函式簡易的寫法"><a href="#箭頭函式簡易的寫法" class="headerlink" title="箭頭函式簡易的寫法"></a>箭頭函式簡易的寫法</h3><p>1.只有一個參數的時候可以不用加箭頭前面的小括號</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">multi</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a * <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>2.如果只有一行表達式或是只有回傳一個值可以把大括弧拿掉，但是有這樣寫就意味者自帶 return，所以實際上是省略了{}還有 return</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">multi</span> = (<span class="params">a</span>) =&gt; a * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="箭頭函式的特性"><a href="#箭頭函式的特性" class="headerlink" title="箭頭函式的特性"></a>箭頭函式的特性</h3><p>1.this 通常指向全域或是說最近的非箭頭函式的 this 值 2.沒有建構函式 3.在 JSX 中可能會看到下面那這種()寫法這是因為已經只有一行的狀況下可以省略掉大括弧，那為什麼可以省略?因為在()為群組運算子 Grouping operator 視為同一行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">callName</span> = (<span class="params">props</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Tom<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="引用資料"><a href="#引用資料" class="headerlink" title="引用資料"></a>引用資料</h2><p>MDN <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL0RlZmF1bHRfcGFyYW1ldGVycw==">預設參數( Default parameters )<i class="fa fa-external-link-alt"></i></span><br>MDN <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9HbG9zc2FyeS9JSUZF">IIFE<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 8 字串陣列互相變化的方法 split &amp; join</title>
    <url>/2023/09/22/Day%208%20%E5%AD%97%E4%B8%B2%E9%99%A3%E5%88%97%E4%BA%92%E7%9B%B8%E8%AE%8A%E5%8C%96%E7%9A%84%E6%96%B9%E6%B3%95%20split%20&amp;%20join/</url>
    <content><![CDATA[<p>今天要來介紹的是字串怎麼變成陣列還有陣列怎麼變成字串，在陣列的方法中已經存在著與字串互相轉換的方法，只是分別是不同的語法，首先是字串轉陣列的方法</p>
<span id="more"></span>

<h3 id="split"><a href="#split" class="headerlink" title=".split()"></a>.split()</h3><p>顧名思義，split 有分開的意思，在這裡就是把字串分開成陣列那要怎麼分開?可以在小括弧裡面指定需要分開的字符，有三種狀況範例如下:</p>
<p>狀況一:裡面不帶值，會把一串字串包在同一個陣列的 index 裡，也就是長度為 1 的陣列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newArray = string.<span class="title function_">split</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day8-1_ckljel.png"></p>
<p>狀況二:裡面有帶參數但其值為空,會把一個字一個字的拆開來變成陣列，換句話說每個字就是一個 index</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> newArray = string.<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day8-2_a60vku.png"></p>
<p>狀況三:裡面有帶參數其值為空白鍵字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;1 2 3 4 5&quot;</span>; <span class="comment">//用空白鍵字符分開</span></span><br><span class="line"><span class="keyword">let</span> newArray = string.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897455/ith2023-article-pic/day8-3_wrhtf1.png"></p>
<h3 id="join"><a href="#join" class="headerlink" title=".join()"></a>.join()</h3><p>使用方法其實與 split 極為相似只是整個倒過來了，小括弧裡決定要用什麼連接成字串，以陣列而言通常是”,”預設也是”,”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> string = array.<span class="title function_">join</span>(<span class="string">&quot;,&quot;</span>); <span class="comment">//決定要用什麼連接成字串，以陣列而言通常是&quot;,&quot;預設也是&quot;,&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string);</span><br></pre></td></tr></table></figure>

<p>以上是字串與陣列互換的方法~</p>
<h2 id="引用資料"><a href="#引用資料" class="headerlink" title="引用資料"></a>引用資料</h2><p>MDN <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZA==">Array.prototype.join<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 1 參賽動機以及題目選擇和預計大綱</title>
    <url>/2023/09/21/Day%207%20%E6%90%9C%E5%B0%8B%E9%99%A3%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95-find,findIndex%20&amp;%20filter/</url>
    <content><![CDATA[<h1 id="Day-7-搜尋陣列的方法-find-findIndex-filter"><a href="#Day-7-搜尋陣列的方法-find-findIndex-filter" class="headerlink" title="Day 7 搜尋陣列的方法-find,findIndex &amp; filter"></a>Day 7 搜尋陣列的方法-find,findIndex &amp; filter</h1><p>今天介紹的三個語法是針對陣列的搜尋功能，有 find(),findIndex(),filter()</p>
<span id="more"></span>

<h3 id="find"><a href="#find" class="headerlink" title=".find()"></a>.find()</h3><p>引用 MDN 的描述”find() 方法會回傳第一個滿足所提供之測試函式的元素值。否則回傳 undefined”<br>簡而言之，就是在陣列裡尋找需要的值並進行回傳需要 return，但是只會回傳一次，也竟是滿足條件的第一個值。<br>用法是裡面帶一個 callback，有三個參數: 1.被處理的元素 2.被處理元素的 index 3.被處理的陣列本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> value = array.<span class="title function_">find</span>(<span class="function">(<span class="params">v, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br></pre></td></tr></table></figure>

<h3 id="findIndex"><a href="#findIndex" class="headerlink" title=".findIndex()"></a>.findIndex()</h3><p>用法語 find 一模一樣，只是 find 是回傳值，findIndex 是回傳 index，如果沒有符合條件的值會回傳-1<br>裡面一樣帶一個 callback，有三個參數: 1.被處理的元素 2.被處理元素的 index 3.被處理的陣列本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> index = array.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">v, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index);</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>這是昨日介紹 find 的加強功能版，它可以把在陣列符合指定條件的值儲存成一個&#x3D;&#x3D;新陣列&#x3D;&#x3D;意味著不會修改到遠本的陣列，其用法也是大同小異帶一個 callback 包含如下三個參數，然後寫出需要的判斷式 1.被處理的元素 2.被處理元素的 index 3.被處理的陣列本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> newArray = array.<span class="title function_">filter</span>(<span class="function">(<span class="params">v, i, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="number">3</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray);</span><br></pre></td></tr></table></figure>

<p>這三著其實都很常用到，並沒有誰好誰壞，端看用途而定。</p>
<h2 id="引用資料"><a href="#引用資料" class="headerlink" title="引用資料"></a>引用資料</h2><p>MDN <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvZmluZA==">Array.prototype.find<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 6 其他的陣列方法 slice &amp; splice</title>
    <url>/2023/09/20/Day%206%20%E5%85%B6%E4%BB%96%E7%9A%84%E9%99%A3%E5%88%97%E6%96%B9%E6%B3%95%20slice%20&amp;%20splice/</url>
    <content><![CDATA[<h1 id="Day-6-其他的陣列方法-slice-splice"><a href="#Day-6-其他的陣列方法-slice-splice" class="headerlink" title="Day 6 其他的陣列方法 slice &amp; splice"></a>Day 6 其他的陣列方法 slice &amp; splice</h1><p>前兩天介紹的 4 個方法:shift,unshift,pop,push 都有一個共通點是，都會修改原本的陣列。<br>接下來要介紹的 slice 與上述的不同，&#x3D;&#x3D;不會改變原本的陣列&#x3D;&#x3D;，會傳回一個新陣列值</p>
<span id="more"></span>

<h3 id="slice"><a href="#slice" class="headerlink" title=".slice()"></a>.slice()</h3><p>引用 MDN 的敘述</p>
<blockquote>
<p>方法會回傳一個新陣列物件，為原陣列選擇之 begin 至 end（不含 end）部分的淺拷貝（shallow copy）。而原本的陣列將不會被修改。</p>
</blockquote>
<p>講的白話一點就是，帶入兩個參數分別是開始的 index 和結束的 index，然後把這之間 &#x3D;&#x3D;(不包含結束的)&#x3D;&#x3D; 的陣列複製到新的陣列上，舉例如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let array=[1,2,3,4,5]</span><br><span class="line">let newArray=array.slice(0,2)</span><br><span class="line">console.log(newArray)//輸出:[1,2]</span><br></pre></td></tr></table></figure>

<h4 id="有三點要注意"><a href="#有三點要注意" class="headerlink" title="有三點要注意"></a>有三點要注意</h4><p>1.帶入的 index 參數為負值意思就是從尾部算，僅指定位置而已功能依舊不變還是把這之間(不包含結束的)的陣列複製到新的陣列上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let array=[1,2,3,4,5]</span><br><span class="line">let newArray=array.slice(-0,-2)</span><br><span class="line">console.log(newArray)//輸出:[1,2]</span><br></pre></td></tr></table></figure>

<p>2.可以不帶參數，亦即完整的淺拷貝，也就是完全複製一個新陣列</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let array=[1,2,3,4,5]</span><br><span class="line">let newArray=array.slice()</span><br><span class="line">console.log(newArray)//輸出:[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<p>3.可以指輸入一個值，意思是從哪個 index 開始複製</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let array=[1,2,3,4,5]</span><br><span class="line">let newArray=array.slice(2)</span><br><span class="line">console.log(newArray)//輸出:[3,4,5]</span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title=".splice()"></a>.splice()</h3><p>雖然這個函式與 slice 只差一個字但功用卻不一樣，此函式最不一樣的功能是在陣列中插入新成員，但會&#x3D;&#x3D;改變原有的陣列&#x3D;&#x3D;。<br>其用法稍微複雜一點，裡面需要帶三個參數 1.開始的 index 2.往後刪除的個數(可以為 0) 3.要加入的東西<br><strong>.splice(開始的 index,刪除個數,新東西)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let array=[1,2,3,4,5]</span><br><span class="line">array.splice(1,1,&quot;a&quot;)</span><br><span class="line">console.log(array)//輸出:[1,&quot;a&quot;,3,4,5]</span><br></pre></td></tr></table></figure>

<h2 id="引用資料"><a href="#引用資料" class="headerlink" title="引用資料"></a>引用資料</h2><p>MDN <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc2xpY2U=">Array.prototype.slice<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 5 操作陣列的方法 Part.2-shift &amp; unshift</title>
    <url>/2023/09/19/Day%205%20%E6%93%8D%E4%BD%9C%E9%99%A3%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95%20Part.2-shift%20&amp;%20unshift/</url>
    <content><![CDATA[<p>接著昨天的陣列操作方法，今天會針對 shift,unshift 做介紹</p>
<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day5-1_bmz6gr.jpg"></p>
<span id="more"></span>

<h3 id="shift"><a href="#shift" class="headerlink" title=".shift()"></a>.shift()</h3><p>shift 有移除的意思，這這裡也確實是移除陣列的值，但只有移除首位，裡面不帶參數，但對空陣列使用會回傳 undefined。範例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">array.<span class="title function_">shift</span>(); <span class="comment">//第一次移除，會移除1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br><span class="line">array.<span class="title function_">shift</span>(); <span class="comment">//第二次移除，因為1被移除了，會移除2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p>對空陣列使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [];</span><br><span class="line">array.<span class="title function_">shift</span>(); <span class="comment">//會回傳undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p>結果如下:<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day5-2_jyng9j.png"></p>
<h3 id="unshift"><a href="#unshift" class="headerlink" title=".unshift()"></a>.unshift()</h3><p>在英文裡有 un 就有相反的意思，所以與上面的語法相反就是增加，它可以在陣列首位增加一個會多個值也可以是陣列，用法是在小括弧裡面塞進要添加的東西，範例如下:</p>
<p>可以加入單一值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">array.<span class="title function_">unshift</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day5-3_halhye.png"></p>
<p>也可以加入多個值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">unshift</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day5-4_ogz53r.png"></p>
<p>還可以加入一個陣列，不過裡面會真的變成一個陣列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">unshift</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day5-5_ntdvi6.png"></p>
<p>其實這組用法和 pop,push 用法幾乎一樣只是分別用在頭尾而已，接著還有其他的陣列用法，明天繼續~</p>
<h3 id="另外補充-會回傳新陣列的語法-concat"><a href="#另外補充-會回傳新陣列的語法-concat" class="headerlink" title="另外補充-會回傳新陣列的語法 .concat()"></a>另外補充-會回傳新陣列的語法 .concat()</h3><p>介紹了很多陣列語法，他們都有共同的特點就是不會回傳新陣列，那會回傳新陣列的語法又是怎麼回事呢?<br>這裡以.concat()為例，這個語法的的作用在於合併兩個陣列，並回傳一個新陣列，用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">//要合併的陣列a</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]; <span class="comment">//要合併的陣列b</span></span><br><span class="line"><span class="keyword">let</span> c = a.<span class="title function_">concat</span>(b); <span class="comment">//合併完後的結果陣列c</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//跟原本一樣</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//跟原本一樣</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">//合併完後的結果</span></span><br></pre></td></tr></table></figure>

<p>藉由上述的例子，我們可以看到，即使 a,b 陣列使用了 concat 的這個語法，但由 console.log(a)、console.log( c )得知原本的狀態都沒有改變，這就是 shift、和 shift 差別。下面請了 chatGPT 幫忙整理了會改變原始陣列的方法與不會改變原始陣列的方法，就當作是一個速查表吧~</p>
<table>
<thead>
<tr>
<th>會修改原始陣列</th>
<th>不會修改原始陣列</th>
</tr>
</thead>
<tbody><tr>
<td>push()</td>
<td>concat()</td>
</tr>
<tr>
<td>pop()</td>
<td>slice()</td>
</tr>
<tr>
<td>shift()</td>
<td>join()</td>
</tr>
<tr>
<td>unshift()</td>
<td>map()</td>
</tr>
<tr>
<td>splice()</td>
<td>filter()</td>
</tr>
<tr>
<td>sort()</td>
<td>reduce()</td>
</tr>
<tr>
<td>reverse()</td>
<td>every()</td>
</tr>
<tr>
<td>fill()</td>
<td>some()</td>
</tr>
<tr>
<td>copyWithin()</td>
<td>find()</td>
</tr>
<tr>
<td></td>
<td>findIndex()</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 4 操作陣列的方法 Part.1-push &amp; pop</title>
    <url>/2023/09/18/Day%204%20%E6%93%8D%E4%BD%9C%E9%99%A3%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95%20Part.1-push%20&amp;%20pop/</url>
    <content><![CDATA[<p>相信大家都有看過類似下面這種圖，今天會針對 push,pop 做介紹</p>
<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day4-1_bqqann.jpg"></p>
<span id="more"></span>

<h3 id="push"><a href="#push" class="headerlink" title=".push()"></a>.push()</h3><p>push 顧名思義就是推東西的意思，在這裡就把它當成是推某個東西都陣列的尾巴，此方法會將一個值或多個值也可以說是陣列加進陣列的尾端，回傳值為新陣列的長度。用法是在小括弧內塞進要加入的東西<br>範例如下:</p>
<p>可以加入單一值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">array.<span class="title function_">push</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p>也可以加入多個值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">push</span>(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p>還可以加入一個陣列，不過裡面會真的變成一個陣列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">push</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day4-2_r0ln7l.png"></p>
<p>如果需要完整合併需要用展開運算子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">push</span>(...[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897454/ith2023-article-pic/day4-3_e6ymxz.png"></p>
<h3 id="pop"><a href="#pop" class="headerlink" title=".pop()"></a>.pop()</h3><p>pop 當作動詞在劍橋字典裡翻成-使什麼彈出的意思，在這裡它的作用是使陣列的末端彈出一個值，說直白一點就是刪除陣列末端的值。裡面不需要帶任何參數，但是如果對空陣列使用會回傳 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array.<span class="title function_">pop</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array);</span><br></pre></td></tr></table></figure>

<p>附帶一提，pop 可以回傳被刪除的值，範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> popTest = array.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(popTest); <span class="comment">//回傳刪除的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(array); <span class="comment">//刪除後的原陣列</span></span><br></pre></td></tr></table></figure>

<p>以上兩個語法為對陣列末端進增加以及刪除的方法，當然同時也有針對陣列開頭的增加刪除方法，留作明天介紹</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 3 查詢陣列的方法-forEach &amp; map</title>
    <url>/2023/09/17/Day%203%20%E6%9F%A5%E8%A9%A2%E9%99%A3%E5%88%97%E7%9A%84%E6%96%B9%E6%B3%95-forEach%20&amp;%20map/</url>
    <content><![CDATA[<p>在學習 React 之前，會需要瞭解一些 javascript 的基礎概念，常言道”javascript 學得好，react 沒煩惱”，其中陣列的方法倒是蠻常用到的，尤其.map()在資料的呈現處理上是蠻常用到的技巧，因為 map 的用法與 forEach 實在太相似了，所以從 forEach 來了解 map 我認為是一個不錯的方法，那就接著往下看~</p>
<span id="more"></span>

<h3 id="forEach"><a href="#forEach" class="headerlink" title=".forEach()"></a>.forEach()</h3><p>是一個遍歷陣列的方法，說的直接一點就是查詢陣列裡面的內容並對其做一些操作。裡面需要帶一個 callback function，裡面包含三個參數如下: 1.陣列裡面的值 2.陣列的 index 3.陣列本身</p>
<p>其方法是不能被&#x3D;&#x3D;中斷的&#x3D;&#x3D;，換句話說就是不能 return，也就是說不會回傳值。<br>範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, index, array2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;index:&quot;</span> + index);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array2); <span class="comment">//陣列本身</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>輸出結果:<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day3-1_fikkzu.png"></p>
<h3 id="map"><a href="#map" class="headerlink" title=".map()"></a>.map()</h3><p>同樣是可以遍歷陣列的一個方法，用法也跟 forEach 相似，也是需要帶一個 callback 裡面也是帶三個參數: 1.陣列裡面的值 2.陣列的 index 3.陣列本身</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">array.<span class="title function_">map</span>(<span class="function">(<span class="params">value, index, array2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;value:&quot;</span> + value);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;index:&quot;</span> + index);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(array2); <span class="comment">//陣列本身</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day3-2_pzsotb.png"></p>
<p>但此方法&#x3D;&#x3D;會回傳&#x3D;&#x3D;一個新陣列，範例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newArray = array.<span class="title function_">map</span>(<span class="function">(<span class="params">value, index, array2</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArray); <span class="comment">//輸出結果:[2,4,6,8,10]</span></span><br></pre></td></tr></table></figure>

<p>輸出結果:<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897453/ith2023-article-pic/day3-3_j2oxp0.png"></p>
<p>總之，forEach 主要用於執行操作而不生成新陣列，而 map 用於生成一個新陣列，其中包含經過處理後的值。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 2 My VS Code Tour</title>
    <url>/2023/09/16/Day%202%20My%20VS%20Code%20Tour/</url>
    <content><![CDATA[<h2 id="簡介"><a href="#簡介" class="headerlink" title="簡介"></a>簡介</h2><p>首先第一邊當然是介紹我們的生財工具 VS Code 啦~相信大家都有自己習慣的環境和模式，今天來分享我的 VS Code 相關的開發設定。</p>
<span id="more"></span>

<h2 id="VS-Code-概述"><a href="#VS-Code-概述" class="headerlink" title="VS Code 概述"></a>VS Code 概述</h2><p>VS Code 是一個功能豐富的程式碼編輯器，支援多種程式語言，例如 JavaScript、HTML&#x2F;CSS 等等。對於軟體開發者來說，它是一個非常靈活且易於使用的工具。</p>
<p>除了強大的基本功能外，VS Code 還可以透過安裝套件來擴展其功能。這些套件提供了各種方便的功能，幫助我們更有效率地開發。</p>
<h2 id="背景知識"><a href="#背景知識" class="headerlink" title="背景知識"></a>背景知識</h2><ul>
<li>VS Code</li>
</ul>
<h2 id="內容"><a href="#內容" class="headerlink" title="內容"></a>內容</h2><h3 id="一-VS-Code-常用基本設置"><a href="#一-VS-Code-常用基本設置" class="headerlink" title="(一) VS Code 常用基本設置"></a>(一) VS Code 常用基本設置</h3><ol>
<li><p>自動換行</p>
<ul>
<li>設置方法:<ul>
<li>點擊左下角小齒輪進入設定選單<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897450/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/1_thqkn0.png" alt="圖 0"></li>
<li>搜尋欄搜尋 “Wrap”</li>
<li>在 “Word Wrap” 設置中設定成 “On”<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897451/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/2_qqu8kv.png" alt="圖 1"></li>
</ul>
</li>
<li>效果:<br>Before<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897451/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/3_mjnlzk.png" alt="圖 2"><br>After<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897451/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/4_jpmgzw.png" alt="圖 3"></li>
</ul>
</li>
<li><p>括弧顏色:可以協助整理巢狀結構</p>
<ul>
<li>設置方法:<ul>
<li>在設定中找到 “Colorized Bracket Pairs”，進入 setting.json，貼上下列程式碼<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897451/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/5_efvzja.png" alt="圖 4"><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;editor.bracketPairColorization.enabled&quot;</span>: <span class="literal">true</span>, <span class="comment">//Bracket Pair Colorizer 協助大中小括號（&#123;&#125;、[]、()）一的獨立補上不同色彩(不用可以刪掉)</span></span><br><span class="line"><span class="string">&quot;editor.guides.bracketPairs&quot;</span>: <span class="string">&quot;active&quot;</span>, <span class="comment">//Bracket Pair Colorizer 協助大中小括號（&#123;&#125;、[]、()）一一(不用可以刪掉)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>效果:<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897451/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/6_acjyt8.png" alt="圖 5"></li>
</ul>
</li>
<li><p>自動儲存格式化(自動排版):可以幫忙整理排的散亂的程式碼</p>
<ul>
<li>設置方法:<ul>
<li>找到下列選項設置 “Format On Save” 打勾，就完成了。<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/7_nxie2a.png" alt="圖 8"></li>
</ul>
</li>
<li>效果:<br>Before<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/8_tosmtf.png" alt="圖 9"><br>After<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897452/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/9_ihxizp.png" alt="圖 10"></li>
</ul>
</li>
</ol>
<h3 id="二-常用套件"><a href="#二-常用套件" class="headerlink" title="(二) 常用套件"></a>(二) 常用套件</h3><ul>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWZvcm11bGFoZW5kcnkuYXV0by1jbG9zZS10YWc=">Auto Close Tag<i class="fa fa-external-link-alt"></i></span><br>HTML 自動封閉的套件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPWZvcm11bGFoZW5kcnkuYXV0by1yZW5hbWUtdGFn">Auto Rename Tag<i class="fa fa-external-link-alt"></i></span><br>HTML 可以一起更改頭尾標籤的套件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPU1TLUNFSU5UTC52c2NvZGUtbGFuZ3VhZ2UtcGFjay16aC1oYW50">Chinese (Traditional) Language<i class="fa fa-external-link-alt"></i></span><br>中文化套件</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXN0cmVldHNpZGVzb2Z0d2FyZS5jb2RlLXNwZWxsLWNoZWNrZXI=">Code Spell Checker<i class="fa fa-external-link-alt"></i></span><br>檢查拼字錯誤的套件，debug 的好幫手，效果有點像 Word 拼字檢查那樣<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897450/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/10_j7veqo.png" alt="圖 6"></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW1odXRjaGllLmdpdC1ncmFwaA==">Git Graph<i class="fa fa-external-link-alt"></i></span><br>對於 Git 有漂亮的 GUI 可以看，方便查閱分支以及版本紀錄<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897450/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/11_le2a0b.png" alt="圖 7"></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW9kZXJ3YXQuaW5kZW50LXJhaW5ib3c=">Indent-rainbow<i class="fa fa-external-link-alt"></i></span><br>縮排好幫手，下圖彩虹就是它的效果<br><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703897450/ith2023-article-pic/day2%20My%20VS%20Code%20Tour/12_hj6cta.png" alt="圖 5"></p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXJpdHdpY2tkZXkuTGl2ZVNlcnZlcg==">Live Server<i class="fa fa-external-link-alt"></i></span><br>好用的網頁預覽套件，不過有時候要注意一下路徑位置，有時候會預覽不出來，這時候就要檢查一下路徑位置了</p>
</li>
</ul>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>總結而言，VS Code 擁有強大的功能和豐富的套件生態系統，適合各種程式開發需求。透過介紹常用的基本設置，如自動換行、括弧顏色設置以及自動儲存格式化，我們可以提高程式碼的可讀性和整潔性。此外，常用的套件如 Auto Close Tag、Auto Rename Tag、Chinese (Traditional) Language、Code Spell Checker、Git Graph、Indent-rainbow 以及 Live Server 更進一步提升了開發效率，讓我們能更專注於寫程式，而不用花費太多時間處理繁瑣的細節。</p>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Day 1 參賽動機以及題目選擇和預計大綱</title>
    <url>/2023/09/15/Day%201%20%E5%8F%83%E8%B3%BD%E5%8B%95%E6%A9%9F%E4%BB%A5%E5%8F%8A%E9%A1%8C%E7%9B%AE%E9%81%B8%E6%93%87%E5%92%8C%E9%A0%90%E8%A8%88%E5%A4%A7%E7%B6%B1/</url>
    <content><![CDATA[<h2 id="參賽動機"><a href="#參賽動機" class="headerlink" title="參賽動機"></a>參賽動機</h2><p>一開始想對於學習前端時間有一些得自己留下些什麼，所以題目本來是要分享一些些網頁鐵三角的一些心得，但後來發現我要在一邊學框架的時間一邊寫鐵人賽，可能會有超出我的一些負荷，所以與其蠟燭兩頭燒，那不如就合在一起寫吧!</p>
<h2 id="為什麼選擇-React-作為主題"><a href="#為什麼選擇-React-作為主題" class="headerlink" title="為什麼選擇 React 作為主題"></a>為什麼選擇 React 作為主題</h2><p>最近開始學習框架，想以初學者的心態，分享自己由新手的觀點來理解 React 的想法，一方面記錄學習的過程，另一方面變成是自己學習框架的推力，至於這個題目”那些年我轉生成前端貓咪踏入 React 地獄的那些事”，是剛好我在看 React 的時候一隻貓咪跳上來壓到我的鍵盤，不知道按到什麼畫面跳轉到某部轉生動畫，所以這個題目就出來了。</p>
<span id="more"></span>

<h2 id="文章內容定位"><a href="#文章內容定位" class="headerlink" title="文章內容定位"></a>文章內容定位</h2><p>其實版上有關 React 的教學文蠻多了，而且 React 官方文件其實寫的蠻清楚的，但其實我覺得最難的是從 js 到 React 這段過程中，我以為的 js 跟實際上的 js 差距其實蠻大的，所以這段的系列文章會著墨在踏入 React 之前的這段過程，或許也許能在學 React 的時候少了一點痛苦。</p>
<p><img src="https://res.cloudinary.com/dvxnfdkhf/image/upload/v1703866631/upload_a227be688deddcb574f107617f388372_oaaone.png"></p>
<h2 id="大綱"><a href="#大綱" class="headerlink" title="大綱"></a>大綱</h2><p>大致上會分為兩部分介紹，第一部分會介紹 React 會用到的 JavaScript 的語法或觀念，第二部分，才會是 React</p>
<h3 id="第一部分-JS"><a href="#第一部分-JS" class="headerlink" title="第一部分 JS"></a>第一部分 JS</h3><p>Day 1. 參賽動機以及題目選擇和預計大綱<br>Day 2. My VS Code Tour<br>Day 3. 查詢陣列的方法-forEach &amp; map<br>Day 4. 操作陣列的方法 Part.1-push &amp; pop<br>Day 5. 操作陣列的方法 Part.2-shift &amp; unshift<br>Day 6. 其他的陣列方法 slice &amp; splice<br>Day 7. 搜尋陣列的方法-find,findIndex &amp; filter<br>Day 8. 字串陣列互相變化的方法 split &amp; join<br>Day 9. 函式與箭頭函式<br>Day 10.物件(Object)<br>Day 11.解構賦值(Destructuring assignment)<br>Day 12.其餘運算子 &amp; 展開運算子(Spread Operator &amp; Rest Operator)<br>Day 13.JavaScript 模組(Modules)<br>Day 14.處理同步非同步的方法(Asynchronous &amp; Synchronous)</p>
<h3 id="第二部分-Rreact"><a href="#第二部分-Rreact" class="headerlink" title="第二部分 Rreact"></a>第二部分 Rreact</h3><p>這部分不會帶到太多太難的 hook，最多可能就寫到 useEffect，至於詳細的大綱，等 JS 結束之後會再公布。</p>
<h4 id="最後熱血開賽-希望一切順利"><a href="#最後熱血開賽-希望一切順利" class="headerlink" title="最後熱血開賽~~希望一切順利"></a>最後熱血開賽~~希望一切順利</h4><h2 id="預計參考資料"><a href="#預計參考資料" class="headerlink" title="預計參考資料"></a>預計參考資料</h2><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZWFjdC5kZXYv">React 官網<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudGhlb2RpbnByb2plY3QuY29tLw==">Odin Project<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWNvZGVjYW1wLm9yZy9sZWFybi9mcm9udC1lbmQtZGV2ZWxvcG1lbnQtbGlicmFyaWVzLw==">freeCodeCamp<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtVFcv">MDN<i class="fa fa-external-link-alt"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>鐵人賽</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
